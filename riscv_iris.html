<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>riscv_iris</title></head>
<body>
<code style="display: block">
default&nbsp;Order&nbsp;dec<br>
<br>
$include&nbsp;&lt;smt.sail&gt;<br>
$include&nbsp;&lt;option.sail&gt;<br>
$include&nbsp;&lt;arith.sail&gt;<br>
$include&nbsp;&lt;string.sail&gt;<br>
$include&nbsp;&lt;vector_dec.sail&gt;<br>
$include&nbsp;&lt;regfp.sail&gt;<br>
<br>
val&nbsp;string_startswith&nbsp;=&nbsp;&quot;string_startswith&quot;&nbsp;:&nbsp;(string,&nbsp;string)&nbsp;-&gt;&nbsp;bool<br>
val&nbsp;string_drop&nbsp;=&nbsp;&quot;string_drop&quot;&nbsp;:&nbsp;(string,&nbsp;nat)&nbsp;-&gt;&nbsp;string<br>
val&nbsp;string_take&nbsp;=&nbsp;&quot;string_take&quot;&nbsp;:&nbsp;(string,&nbsp;nat)&nbsp;-&gt;&nbsp;string<br>
val&nbsp;string_length&nbsp;=&nbsp;&quot;string_length&quot;&nbsp;:&nbsp;string&nbsp;-&gt;&nbsp;nat<br>
val&nbsp;string_append&nbsp;=&nbsp;{c:&nbsp;&quot;concat_str&quot;,&nbsp;_:&nbsp;&quot;string_append&quot;}&nbsp;:&nbsp;(string,&nbsp;string)&nbsp;-&gt;&nbsp;string<br>
<br>
val&nbsp;eq_anything&nbsp;=&nbsp;{ocaml:&nbsp;&quot;(fun&nbsp;(x,&nbsp;y)&nbsp;-&gt;&nbsp;x&nbsp;=&nbsp;y)&quot;,&nbsp;interpreter:&nbsp;&quot;eq_anything&quot;,&nbsp;lem:&nbsp;&quot;eq&quot;,&nbsp;coq:&nbsp;&quot;generic_eq&quot;,&nbsp;c:&nbsp;&quot;eq_anything&quot;}&nbsp;:&nbsp;forall&nbsp;('a&nbsp;:&nbsp;Type).&nbsp;('a,&nbsp;'a)&nbsp;-&gt;&nbsp;bool<br>
<br>
overload&nbsp;operator&nbsp;==&nbsp;=&nbsp;{eq_string,&nbsp;eq_anything}<br>
<br>
val&nbsp;&quot;reg_deref&quot;&nbsp;:&nbsp;forall&nbsp;('a&nbsp;:&nbsp;Type).&nbsp;register('a)&nbsp;-&gt;&nbsp;'a&nbsp;effect&nbsp;{rreg}<br>
/*&nbsp;sneaky&nbsp;deref&nbsp;with&nbsp;no&nbsp;effect&nbsp;necessary&nbsp;for&nbsp;bitfield&nbsp;writes&nbsp;*/<br>
val&nbsp;_reg_deref&nbsp;=&nbsp;&quot;reg_deref&quot;&nbsp;:&nbsp;forall&nbsp;('a&nbsp;:&nbsp;Type).&nbsp;register('a)&nbsp;-&gt;&nbsp;'a<br>
<br>
val&nbsp;any_vector_update&nbsp;=&nbsp;{ocaml:&nbsp;&quot;update&quot;,&nbsp;lem:&nbsp;&quot;update_list_dec&quot;,&nbsp;coq:&nbsp;&quot;vector_update&quot;}&nbsp;:&nbsp;forall&nbsp;'n&nbsp;('a&nbsp;:&nbsp;Type).<br>
&nbsp;&nbsp;(vector('n,&nbsp;dec,&nbsp;'a),&nbsp;int,&nbsp;'a)&nbsp;-&gt;&nbsp;vector('n,&nbsp;dec,&nbsp;'a)<br>
<br>
overload&nbsp;vector_update&nbsp;=&nbsp;{any_vector_update}<br>
<br>
val&nbsp;update_subrange&nbsp;=&nbsp;{ocaml:&nbsp;&quot;update_subrange&quot;,&nbsp;interpreter:&nbsp;&quot;update_subrange&quot;,&nbsp;lem:&nbsp;&quot;update_subrange_vec_dec&quot;,&nbsp;coq:&nbsp;&quot;update_subrange_vec_dec&quot;}&nbsp;:&nbsp;forall&nbsp;'n&nbsp;'m&nbsp;'o.<br>
&nbsp;&nbsp;(bits('n),&nbsp;atom('m),&nbsp;atom('o),&nbsp;bits('m&nbsp;-&nbsp;('o&nbsp;-&nbsp;1)))&nbsp;-&gt;&nbsp;bits('n)<br>
<br>
val&nbsp;vector_concat&nbsp;=&nbsp;{ocaml:&nbsp;&quot;append&quot;,&nbsp;lem:&nbsp;&quot;append_list&quot;,&nbsp;coq:&nbsp;&quot;vec_concat&quot;}&nbsp;:&nbsp;forall&nbsp;('n&nbsp;:&nbsp;Int)&nbsp;('m&nbsp;:&nbsp;Int)&nbsp;('a&nbsp;:&nbsp;Type).<br>
&nbsp;&nbsp;(vector('n,&nbsp;dec,&nbsp;'a),&nbsp;vector('m,&nbsp;dec,&nbsp;'a))&nbsp;-&gt;&nbsp;vector('n&nbsp;+&nbsp;'m,&nbsp;dec,&nbsp;'a)<br>
<br>
overload&nbsp;append&nbsp;=&nbsp;{vector_concat}<br>
<br>
overload&nbsp;~&nbsp;=&nbsp;{not_bool,&nbsp;not_vec}<br>
<br>
val&nbsp;neq_vec&nbsp;=&nbsp;{lem:&nbsp;&quot;neq&quot;}&nbsp;:&nbsp;forall&nbsp;'n.&nbsp;(bits('n),&nbsp;bits('n))&nbsp;-&gt;&nbsp;bool<br>
<br>
function&nbsp;neq_vec&nbsp;(x,&nbsp;y)&nbsp;=&nbsp;not_bool(eq_bits(x,&nbsp;y))<br>
<br>
val&nbsp;neq_anything&nbsp;=&nbsp;{lem:&nbsp;&quot;neq&quot;,&nbsp;coq:&nbsp;&quot;generic_neq&quot;}&nbsp;:&nbsp;forall&nbsp;('a&nbsp;:&nbsp;Type).&nbsp;('a,&nbsp;'a)&nbsp;-&gt;&nbsp;bool<br>
<br>
function&nbsp;neq_anything&nbsp;(x,&nbsp;y)&nbsp;=&nbsp;not_bool(x&nbsp;==&nbsp;y)<br>
<br>
overload&nbsp;operator&nbsp;!=&nbsp;=&nbsp;{neq_vec,&nbsp;neq_anything}<br>
<br>
overload&nbsp;operator&nbsp;&&nbsp;=&nbsp;{and_vec}<br>
<br>
overload&nbsp;operator&nbsp;|&nbsp;=&nbsp;{or_vec}<br>
<br>
val&nbsp;string_of_int&nbsp;=&nbsp;{c:&nbsp;&quot;string_of_int&quot;,&nbsp;ocaml:&nbsp;&quot;string_of_int&quot;,&nbsp;interpreter:&nbsp;&quot;string_of_int&quot;,&nbsp;lem:&nbsp;&quot;stringFromInteger&quot;,&nbsp;coq:&nbsp;&quot;string_of_int&quot;}&nbsp;:&nbsp;int&nbsp;-&gt;&nbsp;string<br>
<br>
val&nbsp;&quot;string_of_bits&quot;&nbsp;:&nbsp;forall&nbsp;'n.&nbsp;bits('n)&nbsp;-&gt;&nbsp;string<br>
<br>
function&nbsp;string_of_bit(b:&nbsp;bit)&nbsp;-&gt;&nbsp;string&nbsp;=<br>
&nbsp;&nbsp;match&nbsp;b&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;bitzero&nbsp;=&gt;&nbsp;&quot;0b0&quot;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;bitone&nbsp;=&gt;&nbsp;&quot;0b1&quot;<br>
&nbsp;&nbsp;}<br>
<br>
overload&nbsp;BitStr&nbsp;=&nbsp;{string_of_bits,&nbsp;string_of_bit}<br>
<br>
val&nbsp;xor_vec&nbsp;=&nbsp;{c:&nbsp;&quot;xor_bits&quot;,&nbsp;_:&nbsp;&quot;xor_vec&quot;}&nbsp;:&nbsp;forall&nbsp;'n.&nbsp;(bits('n),&nbsp;bits('n))&nbsp;-&gt;&nbsp;bits('n)<br>
<br>
val&nbsp;int_power&nbsp;=&nbsp;{ocaml:&nbsp;&quot;int_power&quot;,&nbsp;interpreter:&nbsp;&quot;int_power&quot;,&nbsp;lem:&nbsp;&quot;pow&quot;,&nbsp;coq:&nbsp;&quot;pow&quot;,&nbsp;c:&nbsp;&quot;pow_int&quot;}&nbsp;:&nbsp;(int,&nbsp;int)&nbsp;-&gt;&nbsp;int<br>
<br>
overload&nbsp;operator&nbsp;^&nbsp;=&nbsp;{xor_vec,&nbsp;int_power,&nbsp;concat_str}<br>
<br>
val&nbsp;sub_vec&nbsp;=&nbsp;{c:&nbsp;&quot;sub_bits&quot;,&nbsp;_:&nbsp;&quot;sub_vec&quot;}&nbsp;:&nbsp;forall&nbsp;'n.&nbsp;(bits('n),&nbsp;bits('n))&nbsp;-&gt;&nbsp;bits('n)<br>
<br>
val&nbsp;sub_vec_int&nbsp;=&nbsp;{c:&nbsp;&quot;sub_bits_int&quot;,&nbsp;_:&nbsp;&quot;sub_vec_int&quot;}&nbsp;:&nbsp;forall&nbsp;'n.&nbsp;(bits('n),&nbsp;int)&nbsp;-&gt;&nbsp;bits('n)<br>
<br>
overload&nbsp;operator&nbsp;-&nbsp;=&nbsp;{sub_vec,&nbsp;sub_vec_int}<br>
<br>
val&nbsp;quot_round_zero&nbsp;=&nbsp;{ocaml:&nbsp;&quot;quot_round_zero&quot;,&nbsp;interpreter:&nbsp;&quot;quot_round_zero&quot;,&nbsp;lem:&nbsp;&quot;hardware_quot&quot;,&nbsp;c:&nbsp;&quot;tdiv_int&quot;,&nbsp;coq:&nbsp;&quot;Z.quot&quot;}&nbsp;:&nbsp;(int,&nbsp;int)&nbsp;-&gt;&nbsp;int<br>
val&nbsp;rem_round_zero&nbsp;=&nbsp;{ocaml:&nbsp;&quot;rem_round_zero&quot;,&nbsp;interpreter:&nbsp;&quot;rem_round_zero&quot;,&nbsp;lem:&nbsp;&quot;hardware_mod&quot;,&nbsp;c:&nbsp;&quot;tmod_int&quot;,&nbsp;coq:&nbsp;&quot;Z.rem&quot;}&nbsp;:&nbsp;(int,&nbsp;int)&nbsp;-&gt;&nbsp;int<br>
<br>
/*&nbsp;The&nbsp;following&nbsp;should&nbsp;get&nbsp;us&nbsp;euclidean&nbsp;modulus,&nbsp;and&nbsp;is&nbsp;compatible&nbsp;with&nbsp;pre&nbsp;and&nbsp;post&nbsp;0.9&nbsp;versions&nbsp;of&nbsp;sail&nbsp;*/<br>
overload&nbsp;operator&nbsp;%&nbsp;=&nbsp;{emod_int,&nbsp;mod}<br>
<br>
val&nbsp;min_nat&nbsp;=&nbsp;{ocaml:&nbsp;&quot;min_int&quot;,&nbsp;interpreter:&nbsp;&quot;min_int&quot;,&nbsp;lem:&nbsp;&quot;min&quot;,&nbsp;coq:&nbsp;&quot;min_nat&quot;,&nbsp;c:&nbsp;&quot;min_int&quot;}&nbsp;:&nbsp;(nat,&nbsp;nat)&nbsp;-&gt;&nbsp;nat<br>
<br>
val&nbsp;min_int&nbsp;=&nbsp;{ocaml:&nbsp;&quot;min_int&quot;,&nbsp;interpreter:&nbsp;&quot;min_int&quot;,&nbsp;lem:&nbsp;&quot;min&quot;,&nbsp;coq:&nbsp;&quot;Z.min&quot;,&nbsp;c:&nbsp;&quot;min_int&quot;}&nbsp;:&nbsp;(int,&nbsp;int)&nbsp;-&gt;&nbsp;int<br>
<br>
val&nbsp;max_nat&nbsp;=&nbsp;{ocaml:&nbsp;&quot;max_int&quot;,&nbsp;interpreter:&nbsp;&quot;max_int&quot;,&nbsp;lem:&nbsp;&quot;max&quot;,&nbsp;coq:&nbsp;&quot;max_nat&quot;,&nbsp;c:&nbsp;&quot;max_int&quot;}&nbsp;:&nbsp;(nat,&nbsp;nat)&nbsp;-&gt;&nbsp;nat<br>
<br>
val&nbsp;max_int&nbsp;=&nbsp;{ocaml:&nbsp;&quot;max_int&quot;,&nbsp;interpreter:&nbsp;&quot;max_int&quot;,&nbsp;lem:&nbsp;&quot;max&quot;,&nbsp;coq:&nbsp;&quot;Z.max&quot;,&nbsp;c:&nbsp;&quot;max_int&quot;}&nbsp;:&nbsp;(int,&nbsp;int)&nbsp;-&gt;&nbsp;int<br>
<br>
overload&nbsp;min&nbsp;=&nbsp;{min_nat,&nbsp;min_int}<br>
<br>
overload&nbsp;max&nbsp;=&nbsp;{max_nat,&nbsp;max_int}<br>
<br>
val&nbsp;pow2&nbsp;=&nbsp;&quot;pow2&quot;&nbsp;:&nbsp;forall&nbsp;'n.&nbsp;atom('n)&nbsp;-&gt;&nbsp;atom(2&nbsp;^&nbsp;'n)<br>
<br>
val&nbsp;print&nbsp;=&nbsp;&quot;print_endline&quot;&nbsp;:&nbsp;string&nbsp;-&gt;&nbsp;unit<br>
val&nbsp;print_string&nbsp;=&nbsp;&quot;print_string&quot;&nbsp;:&nbsp;(string,&nbsp;string)&nbsp;-&gt;&nbsp;unit<br>
<br>
val&nbsp;print_instr&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;{ocaml:&nbsp;&quot;Platform.print_instr&quot;,&nbsp;interpreter:&nbsp;&quot;print_endline&quot;,&nbsp;c:&nbsp;&quot;print_instr&quot;,&nbsp;lem:&nbsp;&quot;print_dbg&quot;,&nbsp;_:&nbsp;&quot;print_endline&quot;}&nbsp;:&nbsp;string&nbsp;-&gt;&nbsp;unit<br>
val&nbsp;print_reg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;{ocaml:&nbsp;&quot;Platform.print_reg&quot;,&nbsp;interpreter:&nbsp;&quot;print_endline&quot;,&nbsp;c:&nbsp;&quot;print_reg&quot;,&nbsp;lem:&nbsp;&quot;print_dbg&quot;,&nbsp;_:&nbsp;&quot;print_endline&quot;}&nbsp;:&nbsp;string&nbsp;-&gt;&nbsp;unit<br>
val&nbsp;print_mem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;{ocaml:&nbsp;&quot;Platform.print_mem_access&quot;,&nbsp;interpreter:&nbsp;&quot;print_endline&quot;,&nbsp;c:&nbsp;&quot;print_mem_access&quot;,&nbsp;lem:&nbsp;&quot;print_dbg&quot;,&nbsp;_:&nbsp;&quot;print_endline&quot;}&nbsp;:&nbsp;string&nbsp;-&gt;&nbsp;unit<br>
val&nbsp;print_platform&nbsp;=&nbsp;{ocaml:&nbsp;&quot;Platform.print_platform&quot;,&nbsp;interpreter:&nbsp;&quot;print_endline&quot;,&nbsp;c:&nbsp;&quot;print_platform&quot;,&nbsp;lem:&nbsp;&quot;print_dbg&quot;,&nbsp;_:&nbsp;&quot;print_endline&quot;}&nbsp;:&nbsp;string&nbsp;-&gt;&nbsp;unit<br>
<br>
val&nbsp;get_config_print_instr&nbsp;=&nbsp;{ocaml:&nbsp;&quot;Platform.get_config_print_instr&quot;,&nbsp;c:&quot;get_config_print_instr&quot;}&nbsp;:&nbsp;unit&nbsp;-&gt;&nbsp;bool<br>
val&nbsp;get_config_print_reg&nbsp;=&nbsp;{ocaml:&nbsp;&quot;Platform.get_config_print_reg&quot;,&nbsp;c:&quot;get_config_print_reg&quot;}&nbsp;:&nbsp;unit&nbsp;-&gt;&nbsp;bool<br>
val&nbsp;get_config_print_mem&nbsp;=&nbsp;{ocaml:&nbsp;&quot;Platform.get_config_print_mem&quot;,&nbsp;c:&quot;get_config_print_mem&quot;}&nbsp;:&nbsp;unit&nbsp;-&gt;&nbsp;bool<br>
<br>
val&nbsp;get_config_print_platform&nbsp;=&nbsp;{ocaml:&nbsp;&quot;Platform.get_config_print_platform&quot;,&nbsp;c:&quot;get_config_print_platform&quot;}&nbsp;:&nbsp;unit&nbsp;-&gt;&nbsp;bool<br>
//&nbsp;defaults&nbsp;for&nbsp;other&nbsp;backends<br>
function&nbsp;get_config_print_instr&nbsp;()&nbsp;=&nbsp;false<br>
function&nbsp;get_config_print_reg&nbsp;()&nbsp;=&nbsp;false<br>
function&nbsp;get_config_print_mem&nbsp;()&nbsp;=&nbsp;false<br>
function&nbsp;get_config_print_platform&nbsp;()&nbsp;=&nbsp;false<br>
<br>
val&nbsp;EXTS&nbsp;:&nbsp;forall&nbsp;'n&nbsp;'m,&nbsp;'m&nbsp;&gt;=&nbsp;'n.&nbsp;(implicit('m),&nbsp;bits('n))&nbsp;-&gt;&nbsp;bits('m)<br>
val&nbsp;EXTZ&nbsp;:&nbsp;forall&nbsp;'n&nbsp;'m,&nbsp;'m&nbsp;&gt;=&nbsp;'n.&nbsp;(implicit('m),&nbsp;bits('n))&nbsp;-&gt;&nbsp;bits('m)<br>
<br>
function&nbsp;EXTS(m,&nbsp;v)&nbsp;=&nbsp;sail_sign_extend(v,&nbsp;m)<br>
function&nbsp;EXTZ(m,&nbsp;v)&nbsp;=&nbsp;sail_zero_extend(v,&nbsp;m)<br>
<br>
val&nbsp;zeros_implicit&nbsp;:&nbsp;forall&nbsp;'n,&nbsp;'n&nbsp;&gt;=&nbsp;0&nbsp;.&nbsp;implicit('n)&nbsp;-&gt;&nbsp;bits('n)<br>
function&nbsp;zeros_implicit&nbsp;(n)&nbsp;=&nbsp;sail_zeros(n)<br>
overload&nbsp;zeros&nbsp;=&nbsp;{zeros_implicit}<br>
<br>
val&nbsp;ones&nbsp;:&nbsp;forall&nbsp;'n,&nbsp;'n&nbsp;&gt;=&nbsp;0&nbsp;.&nbsp;implicit('n)&nbsp;-&gt;&nbsp;bits('n)<br>
function&nbsp;ones&nbsp;(n)&nbsp;=&nbsp;sail_ones&nbsp;(n)<br>
<br>
val&nbsp;bool_to_bits&nbsp;:&nbsp;bool&nbsp;-&gt;&nbsp;bits(1)<br>
function&nbsp;bool_to_bits&nbsp;x&nbsp;=&nbsp;if&nbsp;x&nbsp;then&nbsp;0b1&nbsp;else&nbsp;0b0<br>
<br>
val&nbsp;bit_to_bool&nbsp;:&nbsp;bit&nbsp;-&gt;&nbsp;bool<br>
function&nbsp;bit_to_bool&nbsp;b&nbsp;=&nbsp;match&nbsp;b&nbsp;{<br>
&nbsp;&nbsp;bitone&nbsp;&nbsp;=&gt;&nbsp;true,<br>
&nbsp;&nbsp;bitzero&nbsp;=&gt;&nbsp;false<br>
}<br>
<br>
val&nbsp;to_bits&nbsp;:&nbsp;forall&nbsp;'l,&nbsp;'l&nbsp;&gt;=&nbsp;0.(atom('l),&nbsp;int)&nbsp;-&gt;&nbsp;bits('l)<br>
function&nbsp;to_bits&nbsp;(l,&nbsp;n)&nbsp;=&nbsp;get_slice_int(l,&nbsp;n,&nbsp;0)<br>
<br>
infix&nbsp;4&nbsp;&lt;_s<br>
infix&nbsp;4&nbsp;&gt;=_s<br>
infix&nbsp;4&nbsp;&lt;_u<br>
infix&nbsp;4&nbsp;&gt;=_u<br>
infix&nbsp;4&nbsp;&lt;=_u<br>
<br>
val&nbsp;operator&nbsp;&lt;_s&nbsp;&nbsp;:&nbsp;forall&nbsp;'n,&nbsp;'n&nbsp;&gt;&nbsp;0.&nbsp;(bits('n),&nbsp;bits('n))&nbsp;-&gt;&nbsp;bool<br>
val&nbsp;operator&nbsp;&gt;=_s&nbsp;:&nbsp;forall&nbsp;'n,&nbsp;'n&nbsp;&gt;&nbsp;0.&nbsp;(bits('n),&nbsp;bits('n))&nbsp;-&gt;&nbsp;bool<br>
val&nbsp;operator&nbsp;&lt;_u&nbsp;&nbsp;:&nbsp;forall&nbsp;'n.&nbsp;(bits('n),&nbsp;bits('n))&nbsp;-&gt;&nbsp;bool<br>
val&nbsp;operator&nbsp;&gt;=_u&nbsp;:&nbsp;forall&nbsp;'n.&nbsp;(bits('n),&nbsp;bits('n))&nbsp;-&gt;&nbsp;bool<br>
val&nbsp;operator&nbsp;&lt;=_u&nbsp;:&nbsp;forall&nbsp;'n.&nbsp;(bits('n),&nbsp;bits('n))&nbsp;-&gt;&nbsp;bool<br>
<br>
function&nbsp;operator&nbsp;&lt;_s&nbsp;&nbsp;(x,&nbsp;y)&nbsp;=&nbsp;signed(x)&nbsp;&lt;&nbsp;signed(y)<br>
function&nbsp;operator&nbsp;&gt;=_s&nbsp;(x,&nbsp;y)&nbsp;=&nbsp;signed(x)&nbsp;&gt;=&nbsp;signed(y)<br>
function&nbsp;operator&nbsp;&lt;_u&nbsp;&nbsp;(x,&nbsp;y)&nbsp;=&nbsp;unsigned(x)&nbsp;&lt;&nbsp;unsigned(y)<br>
function&nbsp;operator&nbsp;&gt;=_u&nbsp;(x,&nbsp;y)&nbsp;=&nbsp;unsigned(x)&nbsp;&gt;=&nbsp;unsigned(y)<br>
function&nbsp;operator&nbsp;&lt;=_u&nbsp;(x,&nbsp;y)&nbsp;=&nbsp;unsigned(x)&nbsp;&lt;=&nbsp;unsigned(y)<br>
<br>
infix&nbsp;7&nbsp;&gt;&gt;<br>
infix&nbsp;7&nbsp;&lt;&lt;<br>
<br>
val&nbsp;&quot;shift_bits_right&quot;&nbsp;:&nbsp;forall&nbsp;'n&nbsp;'m.&nbsp;(bits('n),&nbsp;bits('m))&nbsp;-&gt;&nbsp;bits('n)<br>
val&nbsp;&quot;shift_bits_left&quot;&nbsp;&nbsp;:&nbsp;forall&nbsp;'n&nbsp;'m.&nbsp;(bits('n),&nbsp;bits('m))&nbsp;-&gt;&nbsp;bits('n)<br>
<br>
val&nbsp;&quot;shiftl&quot;&nbsp;:&nbsp;forall&nbsp;'m&nbsp;'n,&nbsp;'n&nbsp;&gt;=&nbsp;0.&nbsp;(bits('m),&nbsp;atom('n))&nbsp;-&gt;&nbsp;bits('m)<br>
val&nbsp;&quot;shiftr&quot;&nbsp;:&nbsp;forall&nbsp;'m&nbsp;'n,&nbsp;'n&nbsp;&gt;=&nbsp;0.&nbsp;(bits('m),&nbsp;atom('n))&nbsp;-&gt;&nbsp;bits('m)<br>
<br>
overload&nbsp;operator&nbsp;&gt;&gt;&nbsp;=&nbsp;{shift_bits_right,&nbsp;shiftr}<br>
overload&nbsp;operator&nbsp;&lt;&lt;&nbsp;=&nbsp;{shift_bits_left,&nbsp;shiftl}<br>
<br>
/*&nbsp;Ideally&nbsp;these&nbsp;would&nbsp;be&nbsp;sail&nbsp;builtin&nbsp;*/<br>
<br>
function&nbsp;shift_right_arith64&nbsp;(v&nbsp;:&nbsp;bits(64),&nbsp;shift&nbsp;:&nbsp;bits(6))&nbsp;-&gt;&nbsp;bits(64)&nbsp;=<br>
&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;v128&nbsp;:&nbsp;bits(128)&nbsp;=&nbsp;EXTS(v)&nbsp;in<br>
&nbsp;&nbsp;&nbsp;&nbsp;(v128&nbsp;&gt;&gt;&nbsp;shift)[63..0]<br>
<br>
function&nbsp;shift_right_arith32&nbsp;(v&nbsp;:&nbsp;bits(32),&nbsp;shift&nbsp;:&nbsp;bits(5))&nbsp;-&gt;&nbsp;bits(32)&nbsp;=<br>
&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;v64&nbsp;:&nbsp;bits(64)&nbsp;=&nbsp;EXTS(v)&nbsp;in<br>
&nbsp;&nbsp;&nbsp;&nbsp;(v64&nbsp;&gt;&gt;&nbsp;shift)[31..0]<br>
<br>
val&nbsp;&quot;decimal_string_of_bits&quot;&nbsp;:&nbsp;forall&nbsp;'n.&nbsp;bits('n)&nbsp;-&gt;&nbsp;string<br>
val&nbsp;hex_bits&nbsp;:&nbsp;forall&nbsp;'n&nbsp;.&nbsp;(atom('n),&nbsp;bits('n))&nbsp;&lt;-&gt;&nbsp;string<br>
<br>
/*&nbsp;Define&nbsp;the&nbsp;XLEN&nbsp;value&nbsp;for&nbsp;the&nbsp;architecture.&nbsp;*/<br>
<br>
type&nbsp;xlen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Int&nbsp;=&nbsp;64<br>
type&nbsp;xlen_bytes&nbsp;:&nbsp;Int&nbsp;=&nbsp;8<br>
type&nbsp;xlenbits&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;bits(xlen)<br>
/*&nbsp;The&nbsp;default&nbsp;metadata&nbsp;carries&nbsp;no&nbsp;information,&nbsp;and&nbsp;is&nbsp;implemented<br>
&nbsp;*&nbsp;using&nbsp;a&nbsp;unit&nbsp;type.<br>
&nbsp;*/<br>
<br>
type&nbsp;mem_meta&nbsp;=&nbsp;unit<br>
<br>
let&nbsp;default_meta&nbsp;:&nbsp;mem_meta&nbsp;=&nbsp;()<br>
<br>
val&nbsp;__WriteRAM_Meta&nbsp;:&nbsp;forall&nbsp;'n.&nbsp;(xlenbits,&nbsp;atom('n),&nbsp;mem_meta)&nbsp;-&gt;&nbsp;unit&nbsp;effect&nbsp;{wmvt}<br>
function&nbsp;__WriteRAM_Meta(addr,&nbsp;width,&nbsp;meta)&nbsp;=&nbsp;()<br>
<br>
val&nbsp;__ReadRAM_Meta&nbsp;&nbsp;:&nbsp;forall&nbsp;'n.&nbsp;(xlenbits,&nbsp;atom('n))&nbsp;-&gt;&nbsp;mem_meta&nbsp;effect&nbsp;{rmem}<br>
function&nbsp;__ReadRAM_Meta(addr,&nbsp;width)&nbsp;=&nbsp;()<br>
/*&nbsp;These&nbsp;functions&nbsp;define&nbsp;the&nbsp;primitives&nbsp;for&nbsp;physical&nbsp;memory&nbsp;access.<br>
&nbsp;*&nbsp;They&nbsp;depend&nbsp;on&nbsp;the&nbsp;XLEN&nbsp;of&nbsp;the&nbsp;architecture.<br>
&nbsp;*<br>
&nbsp;*&nbsp;They&nbsp;also&nbsp;depend&nbsp;on&nbsp;the&nbsp;type&nbsp;of&nbsp;metadata&nbsp;that&nbsp;is&nbsp;read&nbsp;and&nbsp;written<br>
&nbsp;*&nbsp;to&nbsp;physical&nbsp;memory.&nbsp;&nbsp;For&nbsp;models&nbsp;that&nbsp;do&nbsp;not&nbsp;require&nbsp;this&nbsp;metadata,<br>
&nbsp;*&nbsp;a&nbsp;unit&nbsp;type&nbsp;can&nbsp;be&nbsp;used.<br>
&nbsp;*<br>
&nbsp;*&nbsp;The&nbsp;underlying&nbsp;__read_mem&nbsp;and&nbsp;__write_mem&nbsp;functions&nbsp;are&nbsp;from&nbsp;the<br>
&nbsp;*&nbsp;Sail&nbsp;library.&nbsp;&nbsp;The&nbsp;metadata&nbsp;primitives&nbsp;__{Read,Write}RAM_Meta&nbsp;are<br>
&nbsp;*&nbsp;in&nbsp;prelude_mem_metadata.<br>
&nbsp;*/<br>
<br>
<br>
/*&nbsp;This&nbsp;is&nbsp;a&nbsp;slightly&nbsp;arbitrary&nbsp;limit&nbsp;on&nbsp;the&nbsp;maximum&nbsp;number&nbsp;of&nbsp;bytes<br>
&nbsp;&nbsp;&nbsp;in&nbsp;a&nbsp;memory&nbsp;access.&nbsp;&nbsp;It&nbsp;helps&nbsp;to&nbsp;generate&nbsp;slightly&nbsp;better&nbsp;C&nbsp;code<br>
&nbsp;&nbsp;&nbsp;because&nbsp;it&nbsp;means&nbsp;width&nbsp;argument&nbsp;can&nbsp;be&nbsp;fast&nbsp;native&nbsp;integer.&nbsp;It<br>
&nbsp;&nbsp;&nbsp;would&nbsp;be&nbsp;even&nbsp;better&nbsp;if&nbsp;it&nbsp;could&nbsp;be&nbsp;&lt;=&nbsp;8&nbsp;bytes&nbsp;so&nbsp;that&nbsp;data&nbsp;can<br>
&nbsp;&nbsp;&nbsp;also&nbsp;be&nbsp;a&nbsp;64-bit&nbsp;int&nbsp;but&nbsp;CHERI&nbsp;needs&nbsp;128-bit&nbsp;accesses&nbsp;for<br>
&nbsp;&nbsp;&nbsp;capabilities&nbsp;and&nbsp;SIMD&nbsp;/&nbsp;vector&nbsp;instructions&nbsp;will&nbsp;also&nbsp;need&nbsp;more.&nbsp;*/<br>
type&nbsp;max_mem_access&nbsp;:&nbsp;Int&nbsp;=&nbsp;16<br>
<br>
val&nbsp;write_ram&nbsp;=&nbsp;{lem:&nbsp;&quot;write_ram&quot;,&nbsp;coq:&nbsp;&quot;write_ram&quot;}&nbsp;:&nbsp;forall&nbsp;'n,&nbsp;0&nbsp;&lt;&nbsp;'n&nbsp;&lt;=&nbsp;max_mem_access&nbsp;.&nbsp;(write_kind,&nbsp;xlenbits,&nbsp;atom('n),&nbsp;bits(8&nbsp;*&nbsp;'n),&nbsp;mem_meta)&nbsp;-&gt;&nbsp;bool&nbsp;effect&nbsp;{wmv,&nbsp;wmvt}<br>
<br>
val&nbsp;write_ram_ea&nbsp;:&nbsp;forall&nbsp;'n,&nbsp;0&nbsp;&lt;&nbsp;'n&nbsp;&lt;=&nbsp;max_mem_access&nbsp;.&nbsp;(write_kind,&nbsp;xlenbits,&nbsp;atom('n))&nbsp;-&gt;&nbsp;unit&nbsp;effect&nbsp;{eamem}<br>
function&nbsp;write_ram_ea(wk,&nbsp;addr,&nbsp;width)&nbsp;=<br>
&nbsp;&nbsp;__write_mem_ea(wk,&nbsp;sizeof(xlen),&nbsp;addr,&nbsp;width)<br>
<br>
val&nbsp;read_ram&nbsp;=&nbsp;{lem:&nbsp;&quot;read_ram&quot;,&nbsp;coq:&nbsp;&quot;read_ram&quot;}&nbsp;:&nbsp;forall&nbsp;'n,&nbsp;0&nbsp;&lt;&nbsp;'n&nbsp;&lt;=&nbsp;max_mem_access&nbsp;.&nbsp;&nbsp;(read_kind,&nbsp;xlenbits,&nbsp;atom('n),&nbsp;bool)&nbsp;-&gt;&nbsp;(bits(8&nbsp;*&nbsp;'n),&nbsp;mem_meta)&nbsp;effect&nbsp;{rmem,&nbsp;rmemt}<br>
function&nbsp;read_ram(rk,&nbsp;addr,&nbsp;width,&nbsp;read_meta)&nbsp;=<br>
&nbsp;&nbsp;let&nbsp;meta&nbsp;=&nbsp;if&nbsp;read_meta&nbsp;then&nbsp;__ReadRAM_Meta(addr,&nbsp;width)&nbsp;else&nbsp;default_meta&nbsp;in<br>
&nbsp;&nbsp;(__read_mem(rk,&nbsp;sizeof(xlen),&nbsp;addr,&nbsp;width),&nbsp;meta)<br>
<br>
<br>
/*&nbsp;Basic&nbsp;type&nbsp;and&nbsp;function&nbsp;definitions&nbsp;used&nbsp;pervasively&nbsp;in&nbsp;the&nbsp;model.&nbsp;*/<br>
<br>
/*&nbsp;this&nbsp;value&nbsp;is&nbsp;only&nbsp;defined&nbsp;for&nbsp;the&nbsp;runtime&nbsp;platform&nbsp;for&nbsp;ELF&nbsp;loading<br>
&nbsp;*&nbsp;checks,&nbsp;and&nbsp;not&nbsp;used&nbsp;in&nbsp;the&nbsp;model.<br>
&nbsp;*/<br>
let&nbsp;xlen_val&nbsp;=&nbsp;sizeof(xlen)<br>
<br>
let&nbsp;xlen_max_unsigned&nbsp;=&nbsp;2&nbsp;^&nbsp;sizeof(xlen)&nbsp;-&nbsp;1<br>
let&nbsp;xlen_max_signed&nbsp;=&nbsp;2&nbsp;^&nbsp;(sizeof(xlen)&nbsp;-&nbsp;1)&nbsp;-&nbsp;1<br>
let&nbsp;xlen_min_signed&nbsp;=&nbsp;0&nbsp;-&nbsp;2&nbsp;^&nbsp;(sizeof(xlen)&nbsp;-&nbsp;1)<br>
<br>
type&nbsp;half&nbsp;=&nbsp;bits(16)<br>
type&nbsp;word&nbsp;=&nbsp;bits(32)<br>
<br>
/*&nbsp;register&nbsp;identifiers&nbsp;*/<br>
<br>
type&nbsp;regidx&nbsp;&nbsp;=&nbsp;bits(5)<br>
type&nbsp;cregidx&nbsp;=&nbsp;bits(3)&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;identifiers&nbsp;in&nbsp;RVC&nbsp;instructions&nbsp;*/<br>
type&nbsp;csreg&nbsp;&nbsp;&nbsp;=&nbsp;bits(12)&nbsp;&nbsp;&nbsp;/*&nbsp;CSR&nbsp;addressing&nbsp;*/<br>
<br>
/*&nbsp;register&nbsp;file&nbsp;indexing&nbsp;*/<br>
<br>
type&nbsp;regno&nbsp;('n&nbsp;:&nbsp;Int),&nbsp;0&nbsp;&lt;=&nbsp;'n&nbsp;&lt;&nbsp;32&nbsp;=&nbsp;atom('n)<br>
<br>
val&nbsp;regidx_to_regno&nbsp;:&nbsp;bits(5)&nbsp;-&gt;&nbsp;{'n,&nbsp;0&nbsp;&lt;=&nbsp;'n&nbsp;&lt;&nbsp;32.&nbsp;regno('n)}<br>
function&nbsp;regidx_to_regno&nbsp;b&nbsp;=&nbsp;let&nbsp;'r&nbsp;=&nbsp;unsigned(b)&nbsp;in&nbsp;r<br>
<br>
/*&nbsp;mapping&nbsp;RVC&nbsp;register&nbsp;indices&nbsp;into&nbsp;normal&nbsp;indices&nbsp;*/<br>
val&nbsp;creg2reg_idx&nbsp;:&nbsp;cregidx&nbsp;-&gt;&nbsp;regidx<br>
function&nbsp;creg2reg_idx(creg)&nbsp;=&nbsp;0b01&nbsp;@&nbsp;creg<br>
<br>
/*&nbsp;some&nbsp;architecture&nbsp;and&nbsp;ABI&nbsp;relevant&nbsp;register&nbsp;identifiers&nbsp;*/<br>
let&nbsp;zreg&nbsp;:&nbsp;regidx&nbsp;=&nbsp;0b00000&nbsp;&nbsp;/*&nbsp;x0,&nbsp;zero&nbsp;register&nbsp;&nbsp;*/<br>
let&nbsp;ra&nbsp;&nbsp;&nbsp;:&nbsp;regidx&nbsp;=&nbsp;0b00001&nbsp;&nbsp;/*&nbsp;x1,&nbsp;return&nbsp;address&nbsp;*/<br>
let&nbsp;sp&nbsp;&nbsp;&nbsp;:&nbsp;regidx&nbsp;=&nbsp;0b00010&nbsp;&nbsp;/*&nbsp;x2,&nbsp;stack&nbsp;pointer&nbsp;&nbsp;*/<br>
<br>
/*&nbsp;instruction&nbsp;fields&nbsp;*/<br>
<br>
type&nbsp;opcode&nbsp;=&nbsp;bits(7)<br>
type&nbsp;imm12&nbsp;&nbsp;=&nbsp;bits(12)<br>
type&nbsp;imm20&nbsp;&nbsp;=&nbsp;bits(20)<br>
type&nbsp;amo&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;bits(1)&nbsp;&nbsp;/*&nbsp;amo&nbsp;opcode&nbsp;flags&nbsp;*/<br>
<br>
/*&nbsp;base&nbsp;architecture&nbsp;definitions&nbsp;*/<br>
<br>
enum&nbsp;Architecture&nbsp;=&nbsp;{RV32,&nbsp;RV64,&nbsp;RV128}<br>
type&nbsp;arch_xlen&nbsp;=&nbsp;bits(2)<br>
function&nbsp;architecture(a&nbsp;:&nbsp;arch_xlen)&nbsp;-&gt;&nbsp;option(Architecture)&nbsp;=<br>
&nbsp;&nbsp;match&nbsp;(a)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;0b01&nbsp;=&gt;&nbsp;Some(RV32),<br>
&nbsp;&nbsp;&nbsp;&nbsp;0b10&nbsp;=&gt;&nbsp;Some(RV64),<br>
&nbsp;&nbsp;&nbsp;&nbsp;0b11&nbsp;=&gt;&nbsp;Some(RV128),<br>
&nbsp;&nbsp;&nbsp;&nbsp;_&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;None()<br>
&nbsp;&nbsp;}<br>
<br>
function&nbsp;arch_to_bits(a&nbsp;:&nbsp;Architecture)&nbsp;-&gt;&nbsp;arch_xlen&nbsp;=<br>
&nbsp;&nbsp;match&nbsp;(a)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;RV32&nbsp;&nbsp;=&gt;&nbsp;0b01,<br>
&nbsp;&nbsp;&nbsp;&nbsp;RV64&nbsp;&nbsp;=&gt;&nbsp;0b10,<br>
&nbsp;&nbsp;&nbsp;&nbsp;RV128&nbsp;=&gt;&nbsp;0b11<br>
&nbsp;&nbsp;}<br>
<br>
/*&nbsp;enum&nbsp;denoting&nbsp;whether&nbsp;an&nbsp;executed&nbsp;instruction&nbsp;retires&nbsp;*/<br>
<br>
enum&nbsp;Retired&nbsp;=&nbsp;{RETIRE_SUCCESS,&nbsp;RETIRE_FAIL}<br>
<br>
/*&nbsp;memory&nbsp;access&nbsp;types&nbsp;*/<br>
<br>
union&nbsp;AccessType&nbsp;('a&nbsp;:&nbsp;Type)&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;Read&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;'a,<br>
&nbsp;&nbsp;Write&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;'a,<br>
&nbsp;&nbsp;ReadWrite&nbsp;:&nbsp;'a,<br>
&nbsp;&nbsp;Execute&nbsp;&nbsp;&nbsp;:&nbsp;unit<br>
}<br>
<br>
enum&nbsp;word_width&nbsp;=&nbsp;{BYTE,&nbsp;HALF,&nbsp;WORD,&nbsp;DOUBLE}<br>
/*&nbsp;model-internal&nbsp;exceptions&nbsp;*/<br>
<br>
union&nbsp;exception&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;Error_not_implemented&nbsp;:&nbsp;string,<br>
&nbsp;&nbsp;Error_internal_error&nbsp;&nbsp;:&nbsp;unit<br>
}<br>
<br>
val&nbsp;not_implemented&nbsp;:&nbsp;forall&nbsp;('a&nbsp;:&nbsp;Type).&nbsp;string&nbsp;-&gt;&nbsp;'a&nbsp;effect&nbsp;{escape}<br>
function&nbsp;not_implemented&nbsp;message&nbsp;=&nbsp;throw(Error_not_implemented(message))<br>
<br>
val&nbsp;internal_error&nbsp;:&nbsp;forall&nbsp;('a&nbsp;:&nbsp;Type).&nbsp;string&nbsp;-&gt;&nbsp;'a&nbsp;effect&nbsp;{escape}<br>
function&nbsp;internal_error(s)&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;assert&nbsp;(false,&nbsp;s);<br>
&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;Error_internal_error()<br>
}<br>
<br>
/*&nbsp;instruction&nbsp;opcode&nbsp;grouping&nbsp;*/<br>
enum&nbsp;bop&nbsp;=&nbsp;{RISCV_BEQ,&nbsp;RISCV_BNE,&nbsp;RISCV_BLT,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RISCV_BGE,&nbsp;RISCV_BLTU,&nbsp;RISCV_BGEU}&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;branch&nbsp;ops&nbsp;*/<br>
enum&nbsp;iop&nbsp;=&nbsp;{RISCV_ADDI,&nbsp;RISCV_SLTI,&nbsp;RISCV_SLTIU,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RISCV_XORI,&nbsp;RISCV_ORI,&nbsp;RISCV_ANDI}&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;immediate&nbsp;ops&nbsp;*/<br>
<br>
mapping&nbsp;bool_bits&nbsp;:&nbsp;bool&nbsp;&lt;-&gt;&nbsp;bits(1)&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;true&nbsp;&nbsp;&nbsp;&lt;-&gt;&nbsp;0b1,<br>
&nbsp;&nbsp;false&nbsp;&nbsp;&lt;-&gt;&nbsp;0b0<br>
}<br>
<br>
mapping&nbsp;bool_not_bits&nbsp;:&nbsp;bool&nbsp;&lt;-&gt;&nbsp;bits(1)&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;true&nbsp;&nbsp;&nbsp;&lt;-&gt;&nbsp;0b0,<br>
&nbsp;&nbsp;false&nbsp;&nbsp;&lt;-&gt;&nbsp;0b1<br>
}<br>
<br>
mapping&nbsp;size_bits&nbsp;:&nbsp;word_width&nbsp;&lt;-&gt;&nbsp;bits(2)&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;BYTE&nbsp;&nbsp;&nbsp;&lt;-&gt;&nbsp;0b00,<br>
&nbsp;&nbsp;HALF&nbsp;&nbsp;&nbsp;&lt;-&gt;&nbsp;0b01,<br>
&nbsp;&nbsp;WORD&nbsp;&nbsp;&nbsp;&lt;-&gt;&nbsp;0b10,<br>
&nbsp;&nbsp;DOUBLE&nbsp;&lt;-&gt;&nbsp;0b11<br>
}<br>
<br>
val&nbsp;word_width_bytes&nbsp;:&nbsp;word_width&nbsp;-&gt;&nbsp;{'s,&nbsp;'s&nbsp;==&nbsp;1&nbsp;|&nbsp;'s&nbsp;==&nbsp;2&nbsp;|&nbsp;'s&nbsp;==&nbsp;4&nbsp;|&nbsp;'s&nbsp;==&nbsp;8&nbsp;.&nbsp;atom('s)}<br>
function&nbsp;word_width_bytes&nbsp;width&nbsp;=&nbsp;match&nbsp;width&nbsp;{<br>
&nbsp;&nbsp;BYTE&nbsp;&nbsp;&nbsp;=&gt;&nbsp;1,<br>
&nbsp;&nbsp;HALF&nbsp;&nbsp;&nbsp;=&gt;&nbsp;2,<br>
&nbsp;&nbsp;WORD&nbsp;&nbsp;&nbsp;=&gt;&nbsp;4,<br>
&nbsp;&nbsp;DOUBLE&nbsp;=&gt;&nbsp;8<br>
}<br>
//&nbsp;Extensions&nbsp;for&nbsp;memory&nbsp;Accesstype.<br>
<br>
type&nbsp;ext_access_type&nbsp;=&nbsp;unit<br>
<br>
let&nbsp;Data&nbsp;&nbsp;:&nbsp;ext_access_type&nbsp;=&nbsp;()<br>
<br>
let&nbsp;default_write_acc&nbsp;:&nbsp;ext_access_type&nbsp;=&nbsp;Data<br>
<br>
val&nbsp;accessType_to_str&nbsp;:&nbsp;AccessType(ext_access_type)&nbsp;-&gt;&nbsp;string<br>
function&nbsp;accessType_to_str&nbsp;(a)&nbsp;=<br>
&nbsp;&nbsp;match&nbsp;(a)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;Read(Data)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;&quot;R&quot;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;Write(Data)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;&quot;W&quot;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;ReadWrite(Data)&nbsp;=&gt;&nbsp;&quot;RW&quot;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;Execute()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;&quot;X&quot;<br>
&nbsp;&nbsp;}<br>
<br>
overload&nbsp;to_str&nbsp;=&nbsp;{accessType_to_str}<br>
/*&nbsp;default&nbsp;register&nbsp;type&nbsp;*/<br>
type&nbsp;regtype&nbsp;=&nbsp;xlenbits<br>
<br>
/*&nbsp;default&nbsp;zero&nbsp;register&nbsp;*/<br>
let&nbsp;zero_reg&nbsp;:&nbsp;regtype&nbsp;=&nbsp;EXTZ(0x0)<br>
<br>
/*&nbsp;default&nbsp;register&nbsp;printer&nbsp;*/<br>
val&nbsp;RegStr&nbsp;:&nbsp;regtype&nbsp;-&gt;&nbsp;string<br>
function&nbsp;RegStr(r)&nbsp;=&nbsp;BitStr(r)<br>
<br>
/*&nbsp;conversions&nbsp;*/<br>
<br>
val&nbsp;regval_from_reg&nbsp;:&nbsp;regtype&nbsp;-&gt;&nbsp;xlenbits<br>
function&nbsp;regval_from_reg(r)&nbsp;=&nbsp;r<br>
<br>
val&nbsp;regval_into_reg&nbsp;:&nbsp;xlenbits&nbsp;-&gt;&nbsp;regtype<br>
function&nbsp;regval_into_reg(v)&nbsp;=&nbsp;v<br>
/*&nbsp;program&nbsp;counter&nbsp;*/<br>
<br>
register&nbsp;PC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;xlenbits<br>
register&nbsp;nextPC&nbsp;&nbsp;&nbsp;:&nbsp;xlenbits<br>
<br>
/*&nbsp;internal&nbsp;state&nbsp;to&nbsp;hold&nbsp;instruction&nbsp;bits&nbsp;for&nbsp;faulting&nbsp;instructions&nbsp;*/<br>
register&nbsp;instbits&nbsp;:&nbsp;xlenbits<br>
<br>
/*&nbsp;register&nbsp;file&nbsp;and&nbsp;accessors&nbsp;*/<br>
<br>
register&nbsp;Xs&nbsp;:&nbsp;vector(32,&nbsp;dec,&nbsp;regtype)<br>
<br>
register&nbsp;x1&nbsp;&nbsp;:&nbsp;regtype<br>
register&nbsp;x2&nbsp;&nbsp;:&nbsp;regtype<br>
register&nbsp;x3&nbsp;&nbsp;:&nbsp;regtype<br>
register&nbsp;x4&nbsp;&nbsp;:&nbsp;regtype<br>
register&nbsp;x5&nbsp;&nbsp;:&nbsp;regtype<br>
register&nbsp;x6&nbsp;&nbsp;:&nbsp;regtype<br>
register&nbsp;x7&nbsp;&nbsp;:&nbsp;regtype<br>
register&nbsp;x8&nbsp;&nbsp;:&nbsp;regtype<br>
register&nbsp;x9&nbsp;&nbsp;:&nbsp;regtype<br>
register&nbsp;x10&nbsp;:&nbsp;regtype<br>
register&nbsp;x11&nbsp;:&nbsp;regtype<br>
register&nbsp;x12&nbsp;:&nbsp;regtype<br>
register&nbsp;x13&nbsp;:&nbsp;regtype<br>
register&nbsp;x14&nbsp;:&nbsp;regtype<br>
register&nbsp;x15&nbsp;:&nbsp;regtype<br>
register&nbsp;x16&nbsp;:&nbsp;regtype<br>
register&nbsp;x17&nbsp;:&nbsp;regtype<br>
register&nbsp;x18&nbsp;:&nbsp;regtype<br>
register&nbsp;x19&nbsp;:&nbsp;regtype<br>
register&nbsp;x20&nbsp;:&nbsp;regtype<br>
register&nbsp;x21&nbsp;:&nbsp;regtype<br>
register&nbsp;x22&nbsp;:&nbsp;regtype<br>
register&nbsp;x23&nbsp;:&nbsp;regtype<br>
register&nbsp;x24&nbsp;:&nbsp;regtype<br>
register&nbsp;x25&nbsp;:&nbsp;regtype<br>
register&nbsp;x26&nbsp;:&nbsp;regtype<br>
register&nbsp;x27&nbsp;:&nbsp;regtype<br>
register&nbsp;x28&nbsp;:&nbsp;regtype<br>
register&nbsp;x29&nbsp;:&nbsp;regtype<br>
register&nbsp;x30&nbsp;:&nbsp;regtype<br>
register&nbsp;x31&nbsp;:&nbsp;regtype<br>
<br>
val&nbsp;rX&nbsp;:&nbsp;forall&nbsp;'n,&nbsp;0&nbsp;&lt;=&nbsp;'n&nbsp;&lt;&nbsp;32.&nbsp;regno('n)&nbsp;-&gt;&nbsp;xlenbits&nbsp;effect&nbsp;{rreg,&nbsp;escape}<br>
function&nbsp;rX&nbsp;r&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;let&nbsp;v&nbsp;:&nbsp;regtype&nbsp;=<br>
&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;r&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;=&gt;&nbsp;zero_reg,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;=&gt;&nbsp;x1,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;=&gt;&nbsp;x2,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;=&gt;&nbsp;x3,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;=&gt;&nbsp;x4,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;=&gt;&nbsp;x5,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;=&gt;&nbsp;x6,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;=&gt;&nbsp;x7,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;=&gt;&nbsp;x8,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;=&gt;&nbsp;x9,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;=&gt;&nbsp;x10,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11&nbsp;=&gt;&nbsp;x11,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12&nbsp;=&gt;&nbsp;x12,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13&nbsp;=&gt;&nbsp;x13,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;14&nbsp;=&gt;&nbsp;x14,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15&nbsp;=&gt;&nbsp;x15,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16&nbsp;=&gt;&nbsp;x16,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17&nbsp;=&gt;&nbsp;x17,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18&nbsp;=&gt;&nbsp;x18,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19&nbsp;=&gt;&nbsp;x19,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;20&nbsp;=&gt;&nbsp;x20,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;21&nbsp;=&gt;&nbsp;x21,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;22&nbsp;=&gt;&nbsp;x22,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;23&nbsp;=&gt;&nbsp;x23,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;24&nbsp;=&gt;&nbsp;x24,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;25&nbsp;=&gt;&nbsp;x25,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;26&nbsp;=&gt;&nbsp;x26,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;27&nbsp;=&gt;&nbsp;x27,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;28&nbsp;=&gt;&nbsp;x28,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;29&nbsp;=&gt;&nbsp;x29,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;30&nbsp;=&gt;&nbsp;x30,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;31&nbsp;=&gt;&nbsp;x31,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_&nbsp;&nbsp;=&gt;&nbsp;{assert(false,&nbsp;&quot;invalid&nbsp;register&nbsp;number&quot;);&nbsp;zero_reg}<br>
&nbsp;&nbsp;&nbsp;&nbsp;};<br>
&nbsp;&nbsp;regval_from_reg(v)<br>
}<br>
<br>
val&nbsp;wX&nbsp;:&nbsp;forall&nbsp;'n,&nbsp;0&nbsp;&lt;=&nbsp;'n&nbsp;&lt;&nbsp;32.&nbsp;(regno('n),&nbsp;xlenbits)&nbsp;-&gt;&nbsp;unit&nbsp;effect&nbsp;{wreg,&nbsp;escape}<br>
function&nbsp;wX&nbsp;(r,&nbsp;in_v)&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;let&nbsp;v&nbsp;=&nbsp;regval_into_reg(in_v);<br>
&nbsp;&nbsp;match&nbsp;r&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;=&gt;&nbsp;(),<br>
&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;=&gt;&nbsp;x1&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;=&gt;&nbsp;x2&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;=&gt;&nbsp;x3&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;=&gt;&nbsp;x4&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;=&gt;&nbsp;x5&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;=&gt;&nbsp;x6&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;=&gt;&nbsp;x7&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;=&gt;&nbsp;x8&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;=&gt;&nbsp;x9&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;=&gt;&nbsp;x10&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;11&nbsp;=&gt;&nbsp;x11&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;12&nbsp;=&gt;&nbsp;x12&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;13&nbsp;=&gt;&nbsp;x13&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;14&nbsp;=&gt;&nbsp;x14&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;15&nbsp;=&gt;&nbsp;x15&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;16&nbsp;=&gt;&nbsp;x16&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;17&nbsp;=&gt;&nbsp;x17&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;18&nbsp;=&gt;&nbsp;x18&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;19&nbsp;=&gt;&nbsp;x19&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;20&nbsp;=&gt;&nbsp;x20&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;21&nbsp;=&gt;&nbsp;x21&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;22&nbsp;=&gt;&nbsp;x22&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;23&nbsp;=&gt;&nbsp;x23&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;24&nbsp;=&gt;&nbsp;x24&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;25&nbsp;=&gt;&nbsp;x25&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;26&nbsp;=&gt;&nbsp;x26&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;27&nbsp;=&gt;&nbsp;x27&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;28&nbsp;=&gt;&nbsp;x28&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;29&nbsp;=&gt;&nbsp;x29&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;30&nbsp;=&gt;&nbsp;x30&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;31&nbsp;=&gt;&nbsp;x31&nbsp;=&nbsp;v,<br>
&nbsp;&nbsp;&nbsp;&nbsp;_&nbsp;&nbsp;=&gt;&nbsp;assert(false,&nbsp;&quot;invalid&nbsp;register&nbsp;number&quot;)<br>
&nbsp;&nbsp;};<br>
&nbsp;&nbsp;if&nbsp;(r&nbsp;!=&nbsp;0)&nbsp;then&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;&nbsp;&nbsp;get_config_print_reg()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then&nbsp;print_reg(&quot;x&quot;&nbsp;^&nbsp;string_of_int(r)&nbsp;^&nbsp;&quot;&nbsp;&lt;-&nbsp;&quot;&nbsp;^&nbsp;RegStr(v));<br>
&nbsp;&nbsp;}<br>
}<br>
<br>
function&nbsp;rX_bits(i:&nbsp;bits(5))&nbsp;-&gt;&nbsp;xlenbits&nbsp;=&nbsp;rX(unsigned(i))<br>
<br>
function&nbsp;wX_bits(i:&nbsp;bits(5),&nbsp;data:&nbsp;xlenbits)&nbsp;-&gt;&nbsp;unit&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;wX(unsigned(i))&nbsp;=&nbsp;data<br>
}<br>
<br>
overload&nbsp;X&nbsp;=&nbsp;{rX_bits,&nbsp;wX_bits,&nbsp;rX,&nbsp;wX}<br>
<br>
val&nbsp;init_base_regs&nbsp;:&nbsp;unit&nbsp;-&gt;&nbsp;unit&nbsp;effect&nbsp;{wreg}<br>
function&nbsp;init_base_regs&nbsp;()&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;x1&nbsp;&nbsp;=&nbsp;zero_reg;<br>
&nbsp;&nbsp;x2&nbsp;&nbsp;=&nbsp;zero_reg;<br>
&nbsp;&nbsp;x3&nbsp;&nbsp;=&nbsp;zero_reg;<br>
&nbsp;&nbsp;x4&nbsp;&nbsp;=&nbsp;zero_reg;<br>
&nbsp;&nbsp;x5&nbsp;&nbsp;=&nbsp;zero_reg;<br>
&nbsp;&nbsp;x6&nbsp;&nbsp;=&nbsp;zero_reg;<br>
&nbsp;&nbsp;x7&nbsp;&nbsp;=&nbsp;zero_reg;<br>
&nbsp;&nbsp;x8&nbsp;&nbsp;=&nbsp;zero_reg;<br>
&nbsp;&nbsp;x9&nbsp;&nbsp;=&nbsp;zero_reg;<br>
&nbsp;&nbsp;x10&nbsp;=&nbsp;zero_reg;<br>
&nbsp;&nbsp;x11&nbsp;=&nbsp;zero_reg;<br>
&nbsp;&nbsp;x12&nbsp;=&nbsp;zero_reg;<br>
&nbsp;&nbsp;x13&nbsp;=&nbsp;zero_reg;<br>
&nbsp;&nbsp;x14&nbsp;=&nbsp;zero_reg;<br>
&nbsp;&nbsp;x15&nbsp;=&nbsp;zero_reg;<br>
&nbsp;&nbsp;x16&nbsp;=&nbsp;zero_reg;<br>
&nbsp;&nbsp;x17&nbsp;=&nbsp;zero_reg;<br>
&nbsp;&nbsp;x18&nbsp;=&nbsp;zero_reg;<br>
&nbsp;&nbsp;x19&nbsp;=&nbsp;zero_reg;<br>
&nbsp;&nbsp;x20&nbsp;=&nbsp;zero_reg;<br>
&nbsp;&nbsp;x21&nbsp;=&nbsp;zero_reg;<br>
&nbsp;&nbsp;x22&nbsp;=&nbsp;zero_reg;<br>
&nbsp;&nbsp;x23&nbsp;=&nbsp;zero_reg;<br>
&nbsp;&nbsp;x24&nbsp;=&nbsp;zero_reg;<br>
&nbsp;&nbsp;x25&nbsp;=&nbsp;zero_reg;<br>
&nbsp;&nbsp;x26&nbsp;=&nbsp;zero_reg;<br>
&nbsp;&nbsp;x27&nbsp;=&nbsp;zero_reg;<br>
&nbsp;&nbsp;x28&nbsp;=&nbsp;zero_reg;<br>
&nbsp;&nbsp;x29&nbsp;=&nbsp;zero_reg;<br>
&nbsp;&nbsp;x30&nbsp;=&nbsp;zero_reg;<br>
&nbsp;&nbsp;x31&nbsp;=&nbsp;zero_reg<br>
}<br>
/*&nbsp;accessors&nbsp;for&nbsp;default&nbsp;architectural&nbsp;addresses,&nbsp;for&nbsp;use&nbsp;from&nbsp;within&nbsp;instructions&nbsp;*/<br>
<br>
/*!<br>
&nbsp;&nbsp;Retrieves&nbsp;the&nbsp;architectural&nbsp;PC&nbsp;value.&nbsp;This&nbsp;is&nbsp;not&nbsp;necessarily&nbsp;the&nbsp;value<br>
&nbsp;&nbsp;found&nbsp;in&nbsp;the&nbsp;PC&nbsp;register&nbsp;as&nbsp;extensions&nbsp;may&nbsp;choose&nbsp;to&nbsp;override&nbsp;this&nbsp;function.<br>
&nbsp;&nbsp;The&nbsp;value&nbsp;in&nbsp;the&nbsp;PC&nbsp;register&nbsp;is&nbsp;the&nbsp;absolute&nbsp;virtual&nbsp;address&nbsp;of&nbsp;the&nbsp;instruction<br>
&nbsp;&nbsp;to&nbsp;fetch.<br>
&nbsp;*/<br>
val&nbsp;get_arch_pc&nbsp;:&nbsp;unit&nbsp;-&gt;&nbsp;xlenbits&nbsp;effect&nbsp;{rreg}<br>
function&nbsp;get_arch_pc()&nbsp;=&nbsp;PC<br>
<br>
val&nbsp;get_next_pc&nbsp;:&nbsp;unit&nbsp;-&gt;&nbsp;xlenbits&nbsp;effect&nbsp;{rreg}<br>
function&nbsp;get_next_pc()&nbsp;=&nbsp;nextPC<br>
<br>
val&nbsp;set_next_pc&nbsp;:&nbsp;xlenbits&nbsp;-&gt;&nbsp;unit&nbsp;effect&nbsp;{wreg}<br>
function&nbsp;set_next_pc(pc)&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;nextPC&nbsp;=&nbsp;pc<br>
}<br>
<br>
val&nbsp;tick_pc&nbsp;:&nbsp;unit&nbsp;-&gt;&nbsp;unit&nbsp;effect&nbsp;{rreg,&nbsp;wreg}<br>
function&nbsp;tick_pc()&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;PC&nbsp;=&nbsp;nextPC<br>
}<br>
<br>
/*&nbsp;Extensions&nbsp;may&nbsp;wish&nbsp;to&nbsp;interpose&nbsp;on&nbsp;fetch,&nbsp;control&nbsp;transfer,&nbsp;and&nbsp;data<br>
&nbsp;*&nbsp;addresses&nbsp;used&nbsp;to&nbsp;access&nbsp;memory&nbsp;and&nbsp;perhaps&nbsp;modify&nbsp;them.&nbsp;&nbsp;This&nbsp;file<br>
&nbsp;*&nbsp;defines&nbsp;the&nbsp;return&nbsp;values&nbsp;used&nbsp;by&nbsp;functions&nbsp;that&nbsp;perform&nbsp;this&nbsp;interposition.<br>
&nbsp;*<br>
&nbsp;*&nbsp;The&nbsp;model&nbsp;defines&nbsp;defaults&nbsp;for&nbsp;these&nbsp;functions&nbsp;in&nbsp;riscv_addr_checks.sail;<br>
&nbsp;*&nbsp;extensions&nbsp;would&nbsp;need&nbsp;to&nbsp;define&nbsp;their&nbsp;own&nbsp;functions&nbsp;to&nbsp;override&nbsp;them.<br>
&nbsp;*/<br>
<br>
union&nbsp;Ext_FetchAddr_Check&nbsp;('a&nbsp;:&nbsp;Type)&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;Ext_FetchAddr_OK&nbsp;&nbsp;:&nbsp;xlenbits,&nbsp;&nbsp;/*&nbsp;PC&nbsp;value&nbsp;to&nbsp;use&nbsp;for&nbsp;the&nbsp;actual&nbsp;fetch&nbsp;*/<br>
&nbsp;&nbsp;Ext_FetchAddr_Error&nbsp;:&nbsp;'a<br>
}<br>
<br>
union&nbsp;Ext_ControlAddr_Check&nbsp;('a&nbsp;:&nbsp;Type)&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;Ext_ControlAddr_OK&nbsp;:&nbsp;xlenbits,&nbsp;/*&nbsp;PC&nbsp;value&nbsp;to&nbsp;use&nbsp;for&nbsp;the&nbsp;target&nbsp;of&nbsp;the&nbsp;control&nbsp;operation&nbsp;*/<br>
&nbsp;&nbsp;Ext_ControlAddr_Error&nbsp;:&nbsp;'a<br>
}<br>
<br>
union&nbsp;Ext_DataAddr_Check&nbsp;('a&nbsp;:&nbsp;Type)&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;Ext_DataAddr_OK&nbsp;:&nbsp;xlenbits,&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Address&nbsp;to&nbsp;use&nbsp;for&nbsp;the&nbsp;data&nbsp;access&nbsp;*/<br>
&nbsp;&nbsp;Ext_DataAddr_Error&nbsp;:&nbsp;'a<br>
}<br>
/*&nbsp;default&nbsp;fetch&nbsp;address&nbsp;checks&nbsp;*/<br>
<br>
type&nbsp;ext_fetch_addr_error&nbsp;=&nbsp;unit<br>
<br>
/*&nbsp;Since&nbsp;fetch&nbsp;is&nbsp;done&nbsp;in&nbsp;granules,&nbsp;the&nbsp;check&nbsp;function&nbsp;gets&nbsp;two&nbsp;arguments:<br>
&nbsp;*&nbsp;start_pc:&nbsp;the&nbsp;PC&nbsp;at&nbsp;the&nbsp;start&nbsp;of&nbsp;the&nbsp;current&nbsp;fetch&nbsp;sequence<br>
&nbsp;*&nbsp;pc:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;PC&nbsp;for&nbsp;the&nbsp;current&nbsp;granule<br>
&nbsp;*<br>
&nbsp;*&nbsp;returns:&nbsp;&nbsp;the&nbsp;*virtual*&nbsp;memory&nbsp;address&nbsp;to&nbsp;use&nbsp;for&nbsp;the&nbsp;fetch.<br>
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;any&nbsp;address&nbsp;translation&nbsp;errors&nbsp;are&nbsp;reported&nbsp;for&nbsp;pc,&nbsp;not&nbsp;the&nbsp;returned&nbsp;value.<br>
&nbsp;*/<br>
function&nbsp;ext_fetch_check_pc(start_pc&nbsp;:&nbsp;xlenbits,&nbsp;pc&nbsp;:&nbsp;xlenbits)&nbsp;-&gt;&nbsp;Ext_FetchAddr_Check(ext_fetch_addr_error)&nbsp;=<br>
&nbsp;&nbsp;Ext_FetchAddr_OK(pc)<br>
<br>
function&nbsp;ext_handle_fetch_check_error(err&nbsp;:&nbsp;ext_fetch_addr_error)&nbsp;-&gt;&nbsp;unit&nbsp;=<br>
&nbsp;&nbsp;()<br>
<br>
/*&nbsp;default&nbsp;control&nbsp;address&nbsp;checks&nbsp;*/<br>
<br>
type&nbsp;ext_control_addr_error&nbsp;=&nbsp;unit<br>
<br>
/*&nbsp;these&nbsp;functions&nbsp;return&nbsp;the&nbsp;address&nbsp;to&nbsp;use&nbsp;as&nbsp;the&nbsp;target&nbsp;for<br>
&nbsp;*&nbsp;the&nbsp;control&nbsp;transfer.&nbsp;&nbsp;any&nbsp;address&nbsp;translation&nbsp;or&nbsp;other&nbsp;errors<br>
&nbsp;*&nbsp;are&nbsp;reported&nbsp;for&nbsp;the&nbsp;original&nbsp;value,&nbsp;not&nbsp;the&nbsp;returned&nbsp;value.<br>
&nbsp;*<br>
&nbsp;*&nbsp;NOTE:&nbsp;the&nbsp;input&nbsp;value&nbsp;does&nbsp;*not*&nbsp;have&nbsp;bit[0]&nbsp;set&nbsp;to&nbsp;0,&nbsp;to&nbsp;enable<br>
&nbsp;*&nbsp;more&nbsp;accurate&nbsp;bounds&nbsp;checking.&nbsp;&nbsp;There&nbsp;is&nbsp;no&nbsp;constraint&nbsp;on&nbsp;the&nbsp;output<br>
&nbsp;*&nbsp;value,&nbsp;which&nbsp;will&nbsp;have&nbsp;bit[0]&nbsp;cleared&nbsp;by&nbsp;the&nbsp;caller&nbsp;if&nbsp;needed.<br>
&nbsp;*/<br>
<br>
/*&nbsp;the&nbsp;control&nbsp;address&nbsp;is&nbsp;derived&nbsp;from&nbsp;a&nbsp;non-PC&nbsp;register,&nbsp;e.g.&nbsp;in&nbsp;JALR&nbsp;*/<br>
function&nbsp;ext_control_check_addr(pc&nbsp;:&nbsp;xlenbits)&nbsp;-&gt;&nbsp;Ext_ControlAddr_Check(ext_control_addr_error)&nbsp;=<br>
&nbsp;&nbsp;Ext_ControlAddr_OK(pc)<br>
<br>
/*&nbsp;the&nbsp;control&nbsp;address&nbsp;is&nbsp;derived&nbsp;from&nbsp;the&nbsp;PC&nbsp;register,&nbsp;e.g.&nbsp;in&nbsp;JAL&nbsp;*/<br>
function&nbsp;ext_control_check_pc(pc&nbsp;:&nbsp;xlenbits)&nbsp;-&gt;&nbsp;Ext_ControlAddr_Check(ext_control_addr_error)&nbsp;=<br>
&nbsp;&nbsp;Ext_ControlAddr_OK(pc)<br>
<br>
function&nbsp;ext_handle_control_check_error(err&nbsp;:&nbsp;ext_control_addr_error)&nbsp;-&gt;&nbsp;unit&nbsp;=<br>
&nbsp;&nbsp;()<br>
<br>
<br>
/*&nbsp;The&nbsp;default&nbsp;data&nbsp;address&nbsp;function&nbsp;does&nbsp;not&nbsp;perform&nbsp;any&nbsp;checks&nbsp;so<br>
&nbsp;&nbsp;&nbsp;just&nbsp;uses&nbsp;unit&nbsp;for&nbsp;error&nbsp;type.&nbsp;*/<br>
type&nbsp;ext_data_addr_error&nbsp;=&nbsp;unit<br>
<br>
/*&nbsp;Default&nbsp;data&nbsp;addr&nbsp;is&nbsp;just&nbsp;base&nbsp;register&nbsp;+&nbsp;immediate&nbsp;offset&nbsp;(may&nbsp;be&nbsp;zero).<br>
&nbsp;&nbsp;&nbsp;Extensions&nbsp;might&nbsp;override&nbsp;and&nbsp;add&nbsp;additional&nbsp;checks.&nbsp;*/<br>
function&nbsp;ext_data_get_addr(base&nbsp;:&nbsp;regidx,&nbsp;offset&nbsp;:&nbsp;xlenbits,&nbsp;acc&nbsp;:&nbsp;AccessType(ext_access_type),&nbsp;width&nbsp;:&nbsp;word_width)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;Ext_DataAddr_Check(ext_data_addr_error)&nbsp;=<br>
&nbsp;&nbsp;let&nbsp;addr&nbsp;=&nbsp;X(base)&nbsp;+&nbsp;offset&nbsp;in<br>
&nbsp;&nbsp;Ext_DataAddr_OK(addr)<br>
<br>
/*&nbsp;Machine-mode&nbsp;and&nbsp;supervisor-mode&nbsp;functionality.&nbsp;*/<br>
<br>
union&nbsp;ExceptionType&nbsp;=&nbsp;{<br>
&nbsp;E_Fetch_Addr_Align&nbsp;&nbsp;&nbsp;:&nbsp;unit,<br>
&nbsp;E_Fetch_Access_Fault&nbsp;:&nbsp;unit,<br>
&nbsp;E_Illegal_Instr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;unit,<br>
&nbsp;E_Breakpoint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;unit,<br>
&nbsp;E_Load_Addr_Align&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;unit,<br>
&nbsp;E_Load_Access_Fault&nbsp;&nbsp;:&nbsp;unit,<br>
&nbsp;E_SAMO_Addr_Align&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;unit,<br>
&nbsp;E_SAMO_Access_Fault&nbsp;&nbsp;:&nbsp;unit,<br>
&nbsp;E_U_EnvCall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;unit,<br>
&nbsp;E_S_EnvCall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;unit,<br>
&nbsp;E_Reserved_10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;unit,<br>
&nbsp;E_M_EnvCall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;unit,<br>
&nbsp;E_Fetch_Page_Fault&nbsp;&nbsp;&nbsp;:&nbsp;unit,<br>
&nbsp;E_Load_Page_Fault&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;unit,<br>
&nbsp;E_Reserved_14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;unit,<br>
&nbsp;E_SAMO_Page_Fault&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;unit,<br>
}<br>
<br>
function&nbsp;handle_mem_exception(addr&nbsp;:&nbsp;xlenbits,&nbsp;e&nbsp;:&nbsp;ExceptionType)&nbsp;-&gt;&nbsp;unit&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;assert(false);<br>
}<br>
<br>
<br>
/*&nbsp;memory&nbsp;access&nbsp;exceptions,&nbsp;defined&nbsp;here&nbsp;for&nbsp;use&nbsp;by&nbsp;the&nbsp;platform&nbsp;model.&nbsp;*/<br>
<br>
union&nbsp;MemoryOpResult&nbsp;('a&nbsp;:&nbsp;Type)&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;MemValue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;'a,<br>
&nbsp;&nbsp;MemException&nbsp;:&nbsp;ExceptionType<br>
}<br>
<br>
val&nbsp;MemoryOpResult_add_meta&nbsp;:&nbsp;forall&nbsp;('t&nbsp;:&nbsp;Type).&nbsp;(MemoryOpResult('t),&nbsp;mem_meta)&nbsp;-&gt;&nbsp;MemoryOpResult(('t,&nbsp;mem_meta))<br>
function&nbsp;MemoryOpResult_add_meta(r,&nbsp;m)&nbsp;=&nbsp;match&nbsp;r&nbsp;{<br>
&nbsp;&nbsp;MemValue(v)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;MemValue(v,&nbsp;m),<br>
&nbsp;&nbsp;MemException(e)&nbsp;=&gt;&nbsp;MemException(e)<br>
}<br>
<br>
val&nbsp;MemoryOpResult_drop_meta&nbsp;:&nbsp;forall&nbsp;('t&nbsp;:&nbsp;Type).&nbsp;MemoryOpResult(('t,&nbsp;mem_meta))&nbsp;-&gt;&nbsp;MemoryOpResult('t)<br>
function&nbsp;MemoryOpResult_drop_meta(r)&nbsp;=&nbsp;match&nbsp;r&nbsp;{<br>
&nbsp;&nbsp;MemValue(v,&nbsp;m)&nbsp;&nbsp;=&gt;&nbsp;MemValue(v),<br>
&nbsp;&nbsp;MemException(e)&nbsp;=&gt;&nbsp;MemException(e)<br>
}<br>
<br>
/*&nbsp;whether&nbsp;the&nbsp;platform&nbsp;supports&nbsp;misaligned&nbsp;accesses&nbsp;without&nbsp;trapping&nbsp;to&nbsp;M-mode.&nbsp;if&nbsp;false,<br>
&nbsp;*&nbsp;misaligned&nbsp;loads/stores&nbsp;are&nbsp;trapped&nbsp;to&nbsp;Machine&nbsp;mode.<br>
&nbsp;*/<br>
function&nbsp;plat_enable_misaligned_access&nbsp;()&nbsp;&nbsp;:&nbsp;unit&nbsp;-&gt;&nbsp;bool&nbsp;=&nbsp;true<br>
<br>
/*&nbsp;Platform-specific&nbsp;handling&nbsp;of&nbsp;instruction&nbsp;faults&nbsp;*/<br>
<br>
function&nbsp;handle_illegal()&nbsp;-&gt;&nbsp;unit&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;assert(false);<br>
}<br>
<br>
/*&nbsp;Physical&nbsp;memory&nbsp;model.<br>
&nbsp;*<br>
&nbsp;*&nbsp;This&nbsp;assumes&nbsp;that&nbsp;the&nbsp;platform&nbsp;memory&nbsp;map&nbsp;has&nbsp;been&nbsp;defined,&nbsp;so&nbsp;that&nbsp;accesses<br>
&nbsp;*&nbsp;to&nbsp;MMIO&nbsp;regions&nbsp;can&nbsp;be&nbsp;dispatched.<br>
&nbsp;*<br>
&nbsp;*&nbsp;The&nbsp;implementation&nbsp;below&nbsp;supports&nbsp;the&nbsp;reading&nbsp;and&nbsp;writing&nbsp;of&nbsp;memory<br>
&nbsp;*&nbsp;metadata&nbsp;in&nbsp;addition&nbsp;to&nbsp;raw&nbsp;memory&nbsp;data.<br>
&nbsp;*<br>
&nbsp;*&nbsp;The&nbsp;external&nbsp;API&nbsp;for&nbsp;this&nbsp;module&nbsp;is<br>
&nbsp;*&nbsp;&nbsp;&nbsp;{mem_read,&nbsp;mem_read_meta,&nbsp;mem_write_ea,&nbsp;mem_write_value_meta,&nbsp;mem_write_value}<br>
&nbsp;*&nbsp;where&nbsp;mem_write_value&nbsp;is&nbsp;a&nbsp;special&nbsp;case&nbsp;of&nbsp;mem_write_value_meta&nbsp;that&nbsp;uses<br>
&nbsp;*&nbsp;a&nbsp;default&nbsp;value&nbsp;of&nbsp;the&nbsp;metadata.<br>
&nbsp;*<br>
&nbsp;*&nbsp;The&nbsp;internal&nbsp;implementation&nbsp;first&nbsp;performs&nbsp;a&nbsp;PMP&nbsp;check&nbsp;(if&nbsp;PMP&nbsp;is<br>
&nbsp;*&nbsp;enabled),&nbsp;and&nbsp;then&nbsp;dispatches&nbsp;to&nbsp;MMIO&nbsp;regions&nbsp;or&nbsp;physical&nbsp;memory&nbsp;as<br>
&nbsp;*&nbsp;per&nbsp;the&nbsp;platform&nbsp;memory&nbsp;map.<br>
&nbsp;*/<br>
<br>
function&nbsp;is_aligned_addr&nbsp;forall&nbsp;'n.&nbsp;(addr&nbsp;:&nbsp;xlenbits,&nbsp;width&nbsp;:&nbsp;atom('n))&nbsp;-&gt;&nbsp;bool&nbsp;=<br>
&nbsp;&nbsp;unsigned(addr)&nbsp;%&nbsp;width&nbsp;==&nbsp;0<br>
<br>
function&nbsp;read_kind_of_flags&nbsp;(aq&nbsp;:&nbsp;bool,&nbsp;rl&nbsp;:&nbsp;bool,&nbsp;res&nbsp;:&nbsp;bool)&nbsp;-&gt;&nbsp;option(read_kind)&nbsp;=<br>
&nbsp;&nbsp;match&nbsp;(aq,&nbsp;rl,&nbsp;res)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;(false,&nbsp;false,&nbsp;false)&nbsp;=&gt;&nbsp;Some(Read_plain),<br>
&nbsp;&nbsp;&nbsp;&nbsp;(true,&nbsp;false,&nbsp;false)&nbsp;&nbsp;=&gt;&nbsp;Some(Read_RISCV_acquire),<br>
&nbsp;&nbsp;&nbsp;&nbsp;(true,&nbsp;true,&nbsp;false)&nbsp;&nbsp;&nbsp;=&gt;&nbsp;Some(Read_RISCV_strong_acquire),<br>
&nbsp;&nbsp;&nbsp;&nbsp;(false,&nbsp;false,&nbsp;true)&nbsp;&nbsp;=&gt;&nbsp;Some(Read_RISCV_reserved),<br>
&nbsp;&nbsp;&nbsp;&nbsp;(true,&nbsp;false,&nbsp;true)&nbsp;&nbsp;&nbsp;=&gt;&nbsp;Some(Read_RISCV_reserved_acquire),<br>
&nbsp;&nbsp;&nbsp;&nbsp;(true,&nbsp;true,&nbsp;true)&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;Some(Read_RISCV_reserved_strong_acquire),<br>
&nbsp;&nbsp;&nbsp;&nbsp;(false,&nbsp;true,&nbsp;false)&nbsp;&nbsp;=&gt;&nbsp;None(),&nbsp;/*&nbsp;should&nbsp;these&nbsp;be&nbsp;instead&nbsp;throwing&nbsp;error_not_implemented&nbsp;as&nbsp;below?&nbsp;*/<br>
&nbsp;&nbsp;&nbsp;&nbsp;(false,&nbsp;true,&nbsp;true)&nbsp;&nbsp;&nbsp;=&gt;&nbsp;None()<br>
&nbsp;&nbsp;}<br>
<br>
//&nbsp;only&nbsp;used&nbsp;for&nbsp;actual&nbsp;memory&nbsp;regions,&nbsp;to&nbsp;avoid&nbsp;MMIO&nbsp;effects<br>
function&nbsp;phys_mem_read&nbsp;forall&nbsp;'n,&nbsp;0&nbsp;&lt;&nbsp;'n&nbsp;&lt;=&nbsp;max_mem_access&nbsp;.&nbsp;(t&nbsp;:&nbsp;AccessType(ext_access_type),&nbsp;paddr&nbsp;:&nbsp;xlenbits,&nbsp;width&nbsp;:&nbsp;atom('n),&nbsp;aq&nbsp;:&nbsp;bool,&nbsp;rl:&nbsp;bool,&nbsp;res&nbsp;:&nbsp;bool,&nbsp;meta&nbsp;:&nbsp;bool)&nbsp;-&gt;&nbsp;MemoryOpResult((bits(8&nbsp;*&nbsp;'n),&nbsp;mem_meta))&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;let&nbsp;result&nbsp;=&nbsp;(match&nbsp;read_kind_of_flags(aq,&nbsp;rl,&nbsp;res)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;Some(rk)&nbsp;=&gt;&nbsp;Some(read_ram(rk,&nbsp;paddr,&nbsp;width,&nbsp;meta)),<br>
&nbsp;&nbsp;&nbsp;&nbsp;None()&nbsp;&nbsp;&nbsp;=&gt;&nbsp;None()<br>
&nbsp;&nbsp;})&nbsp;:&nbsp;option((bits(8&nbsp;*&nbsp;'n),&nbsp;mem_meta));<br>
&nbsp;&nbsp;match&nbsp;(t,&nbsp;result)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;(Execute(),&nbsp;&nbsp;None())&nbsp;=&gt;&nbsp;MemException(E_Fetch_Access_Fault()),<br>
&nbsp;&nbsp;&nbsp;&nbsp;(Read(Data),&nbsp;None())&nbsp;=&gt;&nbsp;MemException(E_Load_Access_Fault()),<br>
&nbsp;&nbsp;&nbsp;&nbsp;(_,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;None())&nbsp;=&gt;&nbsp;MemException(E_SAMO_Access_Fault()),<br>
&nbsp;&nbsp;&nbsp;&nbsp;(_,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Some(v,&nbsp;m))&nbsp;=&gt;&nbsp;{&nbsp;MemValue(v,&nbsp;m)&nbsp;}<br>
&nbsp;&nbsp;}<br>
}<br>
<br>
val&nbsp;mem_read&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;forall&nbsp;'n,&nbsp;0&nbsp;&lt;&nbsp;'n&nbsp;&lt;=&nbsp;max_mem_access&nbsp;.&nbsp;(AccessType(ext_access_type),&nbsp;xlenbits,&nbsp;atom('n),&nbsp;bool,&nbsp;bool,&nbsp;bool)&nbsp;-&gt;&nbsp;MemoryOpResult(bits(8&nbsp;*&nbsp;'n))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;effect&nbsp;{rmem,&nbsp;rmemt,&nbsp;rreg,&nbsp;escape}<br>
<br>
function&nbsp;mem_read&nbsp;(typ,&nbsp;paddr,&nbsp;width,&nbsp;aq,&nbsp;rl,&nbsp;res)&nbsp;=&nbsp;{<br>
&nbsp;let&nbsp;result&nbsp;:&nbsp;MemoryOpResult(bits(8&nbsp;*&nbsp;'n))&nbsp;=<br>
&nbsp;&nbsp;if&nbsp;(aq&nbsp;|&nbsp;res)&nbsp;&&nbsp;(~&nbsp;(is_aligned_addr(paddr,&nbsp;width)))<br>
&nbsp;&nbsp;then&nbsp;MemException(E_Load_Addr_Align())<br>
&nbsp;&nbsp;else&nbsp;match&nbsp;(aq,&nbsp;rl,&nbsp;res)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;(false,&nbsp;true,&nbsp;&nbsp;false)&nbsp;=&gt;&nbsp;throw(Error_not_implemented(&quot;load.rl&quot;)),<br>
&nbsp;&nbsp;&nbsp;&nbsp;(false,&nbsp;true,&nbsp;&nbsp;true)&nbsp;&nbsp;=&gt;&nbsp;throw(Error_not_implemented(&quot;lr.rl&quot;)),<br>
&nbsp;&nbsp;&nbsp;&nbsp;(_,&nbsp;_,&nbsp;_)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;MemoryOpResult_drop_meta(phys_mem_read(typ,&nbsp;paddr,&nbsp;width,&nbsp;aq,&nbsp;rl,&nbsp;res,&nbsp;false))<br>
&nbsp;&nbsp;};<br>
&nbsp;result<br>
}<br>
<br>
val&nbsp;mem_write_ea&nbsp;:&nbsp;forall&nbsp;'n,&nbsp;0&nbsp;&lt;&nbsp;'n&nbsp;&lt;=&nbsp;max_mem_access&nbsp;.&nbsp;(xlenbits,&nbsp;atom('n),&nbsp;bool,&nbsp;bool,&nbsp;bool)&nbsp;-&gt;&nbsp;MemoryOpResult(unit)&nbsp;effect&nbsp;{eamem,&nbsp;escape}<br>
<br>
function&nbsp;mem_write_ea&nbsp;(addr,&nbsp;width,&nbsp;aq,&nbsp;rl,&nbsp;con)&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;if&nbsp;(rl&nbsp;|&nbsp;con)&nbsp;&&nbsp;(~&nbsp;(is_aligned_addr(addr,&nbsp;width)))<br>
&nbsp;&nbsp;then&nbsp;MemException(E_SAMO_Addr_Align())<br>
&nbsp;&nbsp;else&nbsp;match&nbsp;(aq,&nbsp;rl,&nbsp;con)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;(false,&nbsp;false,&nbsp;false)&nbsp;=&gt;&nbsp;MemValue(write_ram_ea(Write_plain,&nbsp;addr,&nbsp;width)),<br>
&nbsp;&nbsp;&nbsp;&nbsp;(false,&nbsp;true,&nbsp;&nbsp;false)&nbsp;=&gt;&nbsp;MemValue(write_ram_ea(Write_RISCV_release,&nbsp;addr,&nbsp;width)),<br>
&nbsp;&nbsp;&nbsp;&nbsp;(false,&nbsp;false,&nbsp;true)&nbsp;&nbsp;=&gt;&nbsp;MemValue(write_ram_ea(Write_RISCV_conditional,&nbsp;addr,&nbsp;width)),<br>
&nbsp;&nbsp;&nbsp;&nbsp;(false,&nbsp;true&nbsp;,&nbsp;true)&nbsp;&nbsp;=&gt;&nbsp;MemValue(write_ram_ea(Write_RISCV_conditional_release,&nbsp;addr,&nbsp;width)),<br>
&nbsp;&nbsp;&nbsp;&nbsp;(true,&nbsp;&nbsp;false,&nbsp;false)&nbsp;=&gt;&nbsp;throw(Error_not_implemented(&quot;store.aq&quot;)),<br>
&nbsp;&nbsp;&nbsp;&nbsp;(true,&nbsp;&nbsp;true,&nbsp;&nbsp;false)&nbsp;=&gt;&nbsp;MemValue(write_ram_ea(Write_RISCV_strong_release,&nbsp;addr,&nbsp;width)),<br>
&nbsp;&nbsp;&nbsp;&nbsp;(true,&nbsp;&nbsp;false,&nbsp;true)&nbsp;&nbsp;=&gt;&nbsp;throw(Error_not_implemented(&quot;sc.aq&quot;)),<br>
&nbsp;&nbsp;&nbsp;&nbsp;(true,&nbsp;&nbsp;true&nbsp;,&nbsp;true)&nbsp;&nbsp;=&gt;&nbsp;MemValue(write_ram_ea(Write_RISCV_conditional_strong_release,&nbsp;addr,&nbsp;width))<br>
&nbsp;&nbsp;}<br>
}<br>
<br>
//&nbsp;only&nbsp;used&nbsp;for&nbsp;actual&nbsp;memory&nbsp;regions,&nbsp;to&nbsp;avoid&nbsp;MMIO&nbsp;effects<br>
function&nbsp;phys_mem_write&nbsp;forall&nbsp;'n,&nbsp;0&nbsp;&lt;&nbsp;'n&nbsp;&lt;=&nbsp;max_mem_access&nbsp;.&nbsp;(wk&nbsp;:&nbsp;write_kind,&nbsp;paddr&nbsp;:&nbsp;xlenbits,&nbsp;width&nbsp;:&nbsp;atom('n),&nbsp;data&nbsp;:&nbsp;bits(8&nbsp;*&nbsp;'n),&nbsp;meta&nbsp;:&nbsp;mem_meta)&nbsp;-&gt;&nbsp;MemoryOpResult(bool)&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;let&nbsp;result&nbsp;=&nbsp;MemValue(write_ram(wk,&nbsp;paddr,&nbsp;width,&nbsp;data,&nbsp;meta));<br>
&nbsp;&nbsp;result<br>
}<br>
<br>
/*&nbsp;Atomic&nbsp;accesses&nbsp;can&nbsp;be&nbsp;done&nbsp;to&nbsp;MMIO&nbsp;regions,&nbsp;e.g.&nbsp;in&nbsp;kernel&nbsp;access&nbsp;to&nbsp;device&nbsp;registers.&nbsp;*/<br>
<br>
/*&nbsp;Memory&nbsp;write&nbsp;with&nbsp;an&nbsp;explicit&nbsp;metadata&nbsp;value.&nbsp;&nbsp;Metadata&nbsp;writes&nbsp;are<br>
&nbsp;*&nbsp;currently&nbsp;assumed&nbsp;to&nbsp;have&nbsp;the&nbsp;same&nbsp;alignment&nbsp;constraints&nbsp;as&nbsp;their<br>
&nbsp;*&nbsp;data.<br>
&nbsp;*&nbsp;NOTE:&nbsp;The&nbsp;wreg&nbsp;effect&nbsp;is&nbsp;due&nbsp;to&nbsp;MMIO,&nbsp;the&nbsp;rreg&nbsp;is&nbsp;due&nbsp;to&nbsp;checking&nbsp;mtime.<br>
&nbsp;*/<br>
val&nbsp;mem_write_value_meta&nbsp;:&nbsp;forall&nbsp;'n,&nbsp;0&nbsp;&lt;&nbsp;'n&nbsp;&lt;=&nbsp;max_mem_access&nbsp;.&nbsp;(xlenbits,&nbsp;atom('n),&nbsp;bits(8&nbsp;*&nbsp;'n),&nbsp;ext_access_type,&nbsp;mem_meta,&nbsp;bool,&nbsp;bool,&nbsp;bool)&nbsp;-&gt;&nbsp;MemoryOpResult(bool)&nbsp;effect&nbsp;{wmv,&nbsp;wmvt,&nbsp;rreg,&nbsp;wreg,&nbsp;escape}<br>
function&nbsp;mem_write_value_meta&nbsp;(paddr,&nbsp;width,&nbsp;value,&nbsp;ext_acc,&nbsp;meta,&nbsp;aq,&nbsp;rl,&nbsp;con)&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;if&nbsp;(rl&nbsp;|&nbsp;con)&nbsp;&&nbsp;(~&nbsp;(is_aligned_addr(paddr,&nbsp;width)))<br>
&nbsp;&nbsp;then&nbsp;MemException(E_SAMO_Addr_Align())<br>
&nbsp;&nbsp;else&nbsp;match&nbsp;(aq,&nbsp;rl,&nbsp;con)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;(false,&nbsp;false,&nbsp;false)&nbsp;=&gt;&nbsp;phys_mem_write(Write_plain,&nbsp;paddr,&nbsp;width,&nbsp;value,&nbsp;meta),<br>
&nbsp;&nbsp;&nbsp;&nbsp;(false,&nbsp;true,&nbsp;&nbsp;false)&nbsp;=&gt;&nbsp;phys_mem_write(Write_RISCV_release,&nbsp;paddr,&nbsp;width,&nbsp;value,&nbsp;meta),<br>
&nbsp;&nbsp;&nbsp;&nbsp;(false,&nbsp;false,&nbsp;true)&nbsp;&nbsp;=&gt;&nbsp;phys_mem_write(Write_RISCV_conditional,&nbsp;paddr,&nbsp;width,&nbsp;value,&nbsp;meta),<br>
&nbsp;&nbsp;&nbsp;&nbsp;(false,&nbsp;true&nbsp;,&nbsp;true)&nbsp;&nbsp;=&gt;&nbsp;phys_mem_write(Write_RISCV_conditional_release,&nbsp;paddr,&nbsp;width,&nbsp;value,&nbsp;meta),<br>
&nbsp;&nbsp;&nbsp;&nbsp;(true,&nbsp;&nbsp;true,&nbsp;&nbsp;false)&nbsp;=&gt;&nbsp;phys_mem_write(Write_RISCV_strong_release,&nbsp;paddr,&nbsp;width,&nbsp;value,&nbsp;meta),<br>
&nbsp;&nbsp;&nbsp;&nbsp;(true,&nbsp;&nbsp;true&nbsp;,&nbsp;true)&nbsp;&nbsp;=&gt;&nbsp;phys_mem_write(Write_RISCV_conditional_strong_release,&nbsp;paddr,&nbsp;width,&nbsp;value,&nbsp;meta),<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;throw&nbsp;an&nbsp;illegal&nbsp;instruction&nbsp;here?<br>
&nbsp;&nbsp;&nbsp;&nbsp;(true,&nbsp;&nbsp;false,&nbsp;false)&nbsp;=&gt;&nbsp;throw(Error_not_implemented(&quot;store.aq&quot;)),<br>
&nbsp;&nbsp;&nbsp;&nbsp;(true,&nbsp;&nbsp;false,&nbsp;true)&nbsp;&nbsp;=&gt;&nbsp;throw(Error_not_implemented(&quot;sc.aq&quot;))<br>
&nbsp;&nbsp;}<br>
}<br>
<br>
/*&nbsp;Memory&nbsp;write&nbsp;with&nbsp;a&nbsp;default&nbsp;metadata&nbsp;value.&nbsp;*/<br>
val&nbsp;mem_write_value&nbsp;:&nbsp;forall&nbsp;'n,&nbsp;0&nbsp;&lt;&nbsp;'n&nbsp;&lt;=&nbsp;max_mem_access&nbsp;.&nbsp;(xlenbits,&nbsp;atom('n),&nbsp;bits(8&nbsp;*&nbsp;'n),&nbsp;bool,&nbsp;bool,&nbsp;bool)&nbsp;-&gt;&nbsp;MemoryOpResult(bool)&nbsp;effect&nbsp;{wmv,&nbsp;wmvt,&nbsp;rreg,&nbsp;wreg,&nbsp;escape}<br>
function&nbsp;mem_write_value&nbsp;(paddr,&nbsp;width,&nbsp;value,&nbsp;aq,&nbsp;rl,&nbsp;con)&nbsp;=<br>
&nbsp;&nbsp;mem_write_value_meta(paddr,&nbsp;width,&nbsp;value,&nbsp;default_write_acc,&nbsp;default_meta,&nbsp;aq,&nbsp;rl,&nbsp;con)<br>
<br>
/*&nbsp;Result&nbsp;of&nbsp;address&nbsp;translation&nbsp;*/<br>
<br>
type&nbsp;ext_ptw&nbsp;=&nbsp;unit<br>
<br>
union&nbsp;TR_Result('paddr&nbsp;:&nbsp;Type,&nbsp;'failure&nbsp;:&nbsp;Type)&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;TR_Address&nbsp;:&nbsp;('paddr,&nbsp;ext_ptw),<br>
&nbsp;&nbsp;TR_Failure&nbsp;:&nbsp;('failure,&nbsp;ext_ptw)<br>
}<br>
<br>
val&nbsp;translateAddr&nbsp;:&nbsp;(xlenbits,&nbsp;AccessType(ext_access_type))&nbsp;-&gt;&nbsp;TR_Result(xlenbits,&nbsp;ExceptionType)&nbsp;effect&nbsp;{escape,&nbsp;rmem,&nbsp;rmemt,&nbsp;rreg,&nbsp;wmv,&nbsp;wmvt,&nbsp;wreg}<br>
function&nbsp;translateAddr(vAddr,&nbsp;ac)&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;TR_Address(vAddr,&nbsp;());<br>
}<br>
<br>
/*&nbsp;Instruction&nbsp;definitions.<br>
&nbsp;*<br>
&nbsp;*&nbsp;This&nbsp;includes&nbsp;decoding,&nbsp;execution,&nbsp;and&nbsp;assembly&nbsp;parsing&nbsp;and&nbsp;printing.<br>
&nbsp;*/<br>
<br>
scattered&nbsp;union&nbsp;ast<br>
<br>
/*&nbsp;returns&nbsp;whether&nbsp;an&nbsp;instruction&nbsp;was&nbsp;retired,&nbsp;used&nbsp;for&nbsp;computing&nbsp;minstret&nbsp;*/<br>
val&nbsp;execute&nbsp;:&nbsp;ast&nbsp;-&gt;&nbsp;Retired&nbsp;effect&nbsp;{escape,&nbsp;wreg,&nbsp;rreg,&nbsp;wmv,&nbsp;wmvt,&nbsp;eamem,&nbsp;rmem,&nbsp;rmemt,&nbsp;barr,&nbsp;exmem,&nbsp;undef}<br>
scattered&nbsp;function&nbsp;execute<br>
<br>
val&nbsp;encdec&nbsp;:&nbsp;ast&nbsp;&lt;-&gt;&nbsp;bits(32)<br>
scattered&nbsp;mapping&nbsp;encdec<br>
<br>
///*&nbsp;see&nbsp;riscv_jalr_seq.sail&nbsp;or&nbsp;riscv_jalr_rmem.sail&nbsp;for&nbsp;the&nbsp;execute&nbsp;clause.&nbsp;*/<br>
//<br>
///*&nbsp;*****************************************************************<br>
//union&nbsp;clause&nbsp;ast&nbsp;=&nbsp;BTYPE&nbsp;:&nbsp;(bits(13),&nbsp;regidx,&nbsp;regidx,&nbsp;bop)<br>
//<br>
//mapping&nbsp;encdec_bop&nbsp;:&nbsp;bop&nbsp;&lt;-&gt;&nbsp;bits(3)&nbsp;=&nbsp;{<br>
//&nbsp;&nbsp;RISCV_BEQ&nbsp;&nbsp;&lt;-&gt;&nbsp;0b000,<br>
//&nbsp;&nbsp;RISCV_BNE&nbsp;&nbsp;&lt;-&gt;&nbsp;0b001,<br>
//&nbsp;&nbsp;RISCV_BLT&nbsp;&nbsp;&lt;-&gt;&nbsp;0b100,<br>
//&nbsp;&nbsp;RISCV_BGE&nbsp;&nbsp;&lt;-&gt;&nbsp;0b101,<br>
//&nbsp;&nbsp;RISCV_BLTU&nbsp;&lt;-&gt;&nbsp;0b110,<br>
//&nbsp;&nbsp;RISCV_BGEU&nbsp;&lt;-&gt;&nbsp;0b111<br>
//}<br>
//<br>
//mapping&nbsp;clause&nbsp;encdec&nbsp;=&nbsp;BTYPE(imm7_6&nbsp;@&nbsp;imm5_0&nbsp;@&nbsp;imm7_5_0&nbsp;@&nbsp;imm5_4_1&nbsp;@&nbsp;0b0,&nbsp;rs2,&nbsp;rs1,&nbsp;op)<br>
//&nbsp;&nbsp;&lt;-&gt;&nbsp;imm7_6&nbsp;:&nbsp;bits(1)&nbsp;@&nbsp;imm7_5_0&nbsp;:&nbsp;bits(6)&nbsp;@&nbsp;rs2&nbsp;@&nbsp;rs1&nbsp;@&nbsp;encdec_bop(op)&nbsp;@&nbsp;imm5_4_1&nbsp;:&nbsp;bits(4)&nbsp;@&nbsp;imm5_0&nbsp;:&nbsp;bits(1)&nbsp;@&nbsp;0b1100011<br>
//<br>
//function&nbsp;clause&nbsp;execute&nbsp;(BTYPE(imm,&nbsp;rs2,&nbsp;rs1,&nbsp;op))&nbsp;=&nbsp;{<br>
//&nbsp;&nbsp;let&nbsp;rs1_val&nbsp;=&nbsp;X(rs1);<br>
//&nbsp;&nbsp;let&nbsp;rs2_val&nbsp;=&nbsp;X(rs2);<br>
//&nbsp;&nbsp;let&nbsp;taken&nbsp;:&nbsp;bool&nbsp;=&nbsp;match&nbsp;op&nbsp;{<br>
//&nbsp;&nbsp;&nbsp;&nbsp;RISCV_BEQ&nbsp;&nbsp;=&gt;&nbsp;rs1_val&nbsp;==&nbsp;rs2_val,<br>
//&nbsp;&nbsp;&nbsp;&nbsp;RISCV_BNE&nbsp;&nbsp;=&gt;&nbsp;rs1_val&nbsp;!=&nbsp;rs2_val,<br>
//&nbsp;&nbsp;&nbsp;&nbsp;RISCV_BLT&nbsp;&nbsp;=&gt;&nbsp;rs1_val&nbsp;&lt;_s&nbsp;rs2_val,<br>
//&nbsp;&nbsp;&nbsp;&nbsp;RISCV_BGE&nbsp;&nbsp;=&gt;&nbsp;rs1_val&nbsp;&gt;=_s&nbsp;rs2_val,<br>
//&nbsp;&nbsp;&nbsp;&nbsp;RISCV_BLTU&nbsp;=&gt;&nbsp;rs1_val&nbsp;&lt;_u&nbsp;rs2_val,<br>
//&nbsp;&nbsp;&nbsp;&nbsp;RISCV_BGEU&nbsp;=&gt;&nbsp;rs1_val&nbsp;&gt;=_u&nbsp;rs2_val<br>
//&nbsp;&nbsp;};<br>
//&nbsp;&nbsp;let&nbsp;t&nbsp;:&nbsp;xlenbits&nbsp;=&nbsp;PC&nbsp;+&nbsp;EXTS(imm);<br>
//&nbsp;&nbsp;if&nbsp;taken&nbsp;then&nbsp;{<br>
//&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Extensions&nbsp;get&nbsp;the&nbsp;first&nbsp;checks&nbsp;on&nbsp;the&nbsp;prospective&nbsp;target&nbsp;address.&nbsp;*/<br>
//&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;ext_control_check_pc(t)&nbsp;{<br>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ext_ControlAddr_Error(e)&nbsp;=&gt;&nbsp;{<br>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert(false);<br>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RETIRE_FAIL<br>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ext_ControlAddr_OK(target)&nbsp;=&gt;&nbsp;{<br>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;bit_to_bool(target[1])&nbsp;&&nbsp;(~&nbsp;(haveRVC()))&nbsp;then&nbsp;{<br>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handle_mem_exception(target,&nbsp;E_Fetch_Addr_Align());<br>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RETIRE_FAIL;<br>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{<br>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set_next_pc(target);<br>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RETIRE_SUCCESS<br>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
//&nbsp;&nbsp;&nbsp;&nbsp;}<br>
//&nbsp;&nbsp;}&nbsp;else&nbsp;RETIRE_SUCCESS<br>
//}<br>
<br>
/*&nbsp;******************************************************************&nbsp;*/<br>
union&nbsp;clause&nbsp;ast&nbsp;=&nbsp;ITYPE&nbsp;:&nbsp;(bits(12),&nbsp;regidx,&nbsp;regidx,&nbsp;iop)<br>
<br>
mapping&nbsp;encdec_iop&nbsp;:&nbsp;iop&nbsp;&lt;-&gt;&nbsp;bits(3)&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;RISCV_ADDI&nbsp;&nbsp;&lt;-&gt;&nbsp;0b000,<br>
&nbsp;&nbsp;RISCV_SLTI&nbsp;&nbsp;&lt;-&gt;&nbsp;0b010,<br>
&nbsp;&nbsp;RISCV_SLTIU&nbsp;&lt;-&gt;&nbsp;0b011,<br>
&nbsp;&nbsp;RISCV_ANDI&nbsp;&nbsp;&lt;-&gt;&nbsp;0b111,<br>
&nbsp;&nbsp;RISCV_ORI&nbsp;&nbsp;&nbsp;&lt;-&gt;&nbsp;0b110,<br>
&nbsp;&nbsp;RISCV_XORI&nbsp;&nbsp;&lt;-&gt;&nbsp;0b100<br>
}<br>
<br>
mapping&nbsp;clause&nbsp;encdec&nbsp;=&nbsp;ITYPE(imm,&nbsp;rs1,&nbsp;rd,&nbsp;op)<br>
&nbsp;&nbsp;&lt;-&gt;&nbsp;imm&nbsp;@&nbsp;rs1&nbsp;@&nbsp;encdec_iop(op)&nbsp;@&nbsp;rd&nbsp;@&nbsp;0b0010011<br>
<br>
function&nbsp;clause&nbsp;execute&nbsp;(ITYPE&nbsp;(imm,&nbsp;rs1,&nbsp;rd,&nbsp;op))&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;let&nbsp;rs1_val&nbsp;=&nbsp;X(rs1);<br>
&nbsp;&nbsp;let&nbsp;immext&nbsp;:&nbsp;xlenbits&nbsp;=&nbsp;EXTS(imm);<br>
&nbsp;&nbsp;let&nbsp;result&nbsp;:&nbsp;xlenbits&nbsp;=&nbsp;match&nbsp;op&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;RISCV_ADDI&nbsp;&nbsp;=&gt;&nbsp;rs1_val&nbsp;+&nbsp;immext,<br>
&nbsp;&nbsp;&nbsp;&nbsp;RISCV_SLTI&nbsp;&nbsp;=&gt;&nbsp;EXTZ(bool_to_bits(rs1_val&nbsp;&lt;_s&nbsp;immext)),<br>
&nbsp;&nbsp;&nbsp;&nbsp;RISCV_SLTIU&nbsp;=&gt;&nbsp;EXTZ(bool_to_bits(rs1_val&nbsp;&lt;_u&nbsp;immext)),<br>
&nbsp;&nbsp;&nbsp;&nbsp;RISCV_ANDI&nbsp;&nbsp;=&gt;&nbsp;rs1_val&nbsp;&&nbsp;immext,<br>
&nbsp;&nbsp;&nbsp;&nbsp;RISCV_ORI&nbsp;&nbsp;&nbsp;=&gt;&nbsp;rs1_val&nbsp;|&nbsp;immext,<br>
&nbsp;&nbsp;&nbsp;&nbsp;RISCV_XORI&nbsp;&nbsp;=&gt;&nbsp;rs1_val&nbsp;^&nbsp;immext<br>
&nbsp;&nbsp;};<br>
&nbsp;&nbsp;X(rd)&nbsp;=&nbsp;result;<br>
&nbsp;&nbsp;RETIRE_SUCCESS<br>
}<br>
<br>
mapping&nbsp;itype_mnemonic&nbsp;:&nbsp;iop&nbsp;&lt;-&gt;&nbsp;string&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;RISCV_ADDI&nbsp;&nbsp;&lt;-&gt;&nbsp;&quot;addi&quot;,<br>
&nbsp;&nbsp;RISCV_SLTI&nbsp;&nbsp;&lt;-&gt;&nbsp;&quot;slti&quot;,<br>
&nbsp;&nbsp;RISCV_SLTIU&nbsp;&lt;-&gt;&nbsp;&quot;sltiu&quot;,<br>
&nbsp;&nbsp;RISCV_XORI&nbsp;&nbsp;&lt;-&gt;&nbsp;&quot;xori&quot;,<br>
&nbsp;&nbsp;RISCV_ORI&nbsp;&nbsp;&nbsp;&lt;-&gt;&nbsp;&quot;ori&quot;,<br>
&nbsp;&nbsp;RISCV_ANDI&nbsp;&nbsp;&lt;-&gt;&nbsp;&quot;andi&quot;<br>
}<br>
<br>
/*&nbsp;******************************************************************&nbsp;*/<br>
union&nbsp;clause&nbsp;ast&nbsp;=&nbsp;LOAD&nbsp;:&nbsp;(bits(12),&nbsp;regidx,&nbsp;regidx,&nbsp;bool,&nbsp;word_width,&nbsp;bool,&nbsp;bool)<br>
<br>
/*&nbsp;unsigned&nbsp;loads&nbsp;are&nbsp;only&nbsp;present&nbsp;for&nbsp;widths&nbsp;strictly&nbsp;less&nbsp;than&nbsp;xlen,<br>
&nbsp;&nbsp;&nbsp;signed&nbsp;loads&nbsp;also&nbsp;present&nbsp;for&nbsp;widths&nbsp;equal&nbsp;to&nbsp;xlen&nbsp;*/<br>
mapping&nbsp;clause&nbsp;encdec&nbsp;=&nbsp;LOAD(imm,&nbsp;rs1,&nbsp;rd,&nbsp;is_unsigned,&nbsp;size,&nbsp;false,&nbsp;false)&nbsp;if&nbsp;(word_width_bytes(size)&nbsp;&lt;&nbsp;sizeof(xlen_bytes))&nbsp;|&nbsp;(not_bool(is_unsigned)&nbsp;&&nbsp;word_width_bytes(size)&nbsp;&lt;=&nbsp;sizeof(xlen_bytes))<br>
&nbsp;&nbsp;&lt;-&gt;&nbsp;imm&nbsp;@&nbsp;rs1&nbsp;@&nbsp;bool_bits(is_unsigned)&nbsp;@&nbsp;size_bits(size)&nbsp;@&nbsp;rd&nbsp;@&nbsp;0b0000011&nbsp;if&nbsp;(word_width_bytes(size)&nbsp;&lt;&nbsp;sizeof(xlen_bytes))&nbsp;|&nbsp;(not_bool(is_unsigned)&nbsp;&&nbsp;word_width_bytes(size)&nbsp;&lt;=&nbsp;sizeof(xlen_bytes))<br>
<br>
val&nbsp;extend_value&nbsp;:&nbsp;forall&nbsp;'n,&nbsp;0&nbsp;&lt;&nbsp;'n&nbsp;&lt;=&nbsp;xlen_bytes.&nbsp;(bool,&nbsp;MemoryOpResult(bits(8&nbsp;*&nbsp;'n)))&nbsp;-&gt;&nbsp;MemoryOpResult(xlenbits)<br>
function&nbsp;extend_value(is_unsigned,&nbsp;value)&nbsp;=&nbsp;match&nbsp;(value)&nbsp;{<br>
&nbsp;&nbsp;MemValue(v)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;MemValue(if&nbsp;is_unsigned&nbsp;then&nbsp;EXTZ(v)&nbsp;else&nbsp;EXTS(v)&nbsp;:&nbsp;xlenbits),<br>
&nbsp;&nbsp;MemException(e)&nbsp;=&gt;&nbsp;MemException(e)<br>
}<br>
<br>
val&nbsp;process_load&nbsp;:&nbsp;forall&nbsp;'n,&nbsp;0&nbsp;&lt;&nbsp;'n&nbsp;&lt;=&nbsp;xlen_bytes.&nbsp;(regidx,&nbsp;xlenbits,&nbsp;MemoryOpResult(bits(8&nbsp;*&nbsp;'n)),&nbsp;bool)&nbsp;-&gt;&nbsp;Retired&nbsp;effect&nbsp;{escape,&nbsp;rreg,&nbsp;wreg}<br>
function&nbsp;process_load(rd,&nbsp;addr,&nbsp;value,&nbsp;is_unsigned)&nbsp;=<br>
&nbsp;&nbsp;match&nbsp;extend_value(is_unsigned,&nbsp;value)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;MemValue(result)&nbsp;=&gt;&nbsp;{&nbsp;X(rd)&nbsp;=&nbsp;result;&nbsp;RETIRE_SUCCESS&nbsp;},<br>
&nbsp;&nbsp;&nbsp;&nbsp;MemException(e)&nbsp;&nbsp;=&gt;&nbsp;{&nbsp;handle_mem_exception(addr,&nbsp;e);&nbsp;RETIRE_FAIL&nbsp;}<br>
&nbsp;&nbsp;}<br>
<br>
function&nbsp;check_misaligned(vaddr&nbsp;:&nbsp;xlenbits,&nbsp;width&nbsp;:&nbsp;word_width)&nbsp;-&gt;&nbsp;bool&nbsp;=<br>
&nbsp;&nbsp;if&nbsp;&nbsp;&nbsp;plat_enable_misaligned_access()&nbsp;then&nbsp;false<br>
&nbsp;&nbsp;else&nbsp;match&nbsp;width&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BYTE&nbsp;&nbsp;&nbsp;=&gt;&nbsp;false,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HALF&nbsp;&nbsp;&nbsp;=&gt;&nbsp;vaddr[0]&nbsp;==&nbsp;bitone,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WORD&nbsp;&nbsp;&nbsp;=&gt;&nbsp;vaddr[0]&nbsp;==&nbsp;bitone&nbsp;|&nbsp;vaddr[1]&nbsp;==&nbsp;bitone,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DOUBLE&nbsp;=&gt;&nbsp;vaddr[0]&nbsp;==&nbsp;bitone&nbsp;|&nbsp;vaddr[1]&nbsp;==&nbsp;bitone&nbsp;|&nbsp;vaddr[2]&nbsp;==&nbsp;bitone<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
function&nbsp;clause&nbsp;execute(LOAD(imm,&nbsp;rs1,&nbsp;rd,&nbsp;is_unsigned,&nbsp;width,&nbsp;aq,&nbsp;rl))&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;let&nbsp;offset&nbsp;:&nbsp;xlenbits&nbsp;=&nbsp;EXTS(imm);<br>
&nbsp;&nbsp;/*&nbsp;Get&nbsp;the&nbsp;address,&nbsp;X(rs1)&nbsp;+&nbsp;offset.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Some&nbsp;extensions&nbsp;perform&nbsp;additional&nbsp;checks&nbsp;on&nbsp;address&nbsp;validity.&nbsp;*/<br>
&nbsp;&nbsp;match&nbsp;ext_data_get_addr(rs1,&nbsp;offset,&nbsp;Read(Data),&nbsp;width)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;Ext_DataAddr_Error(e)&nbsp;&nbsp;=&gt;&nbsp;{&nbsp;assert(false);&nbsp;RETIRE_FAIL&nbsp;},<br>
&nbsp;&nbsp;&nbsp;&nbsp;Ext_DataAddr_OK(vaddr)&nbsp;=&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;&nbsp;&nbsp;check_misaligned(vaddr,&nbsp;width)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then&nbsp;{&nbsp;handle_mem_exception(vaddr,&nbsp;E_Load_Addr_Align());&nbsp;RETIRE_FAIL&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;match&nbsp;translateAddr(vaddr,&nbsp;Read(Data))&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TR_Failure(e,&nbsp;_)&nbsp;=&gt;&nbsp;{&nbsp;handle_mem_exception(vaddr,&nbsp;e);&nbsp;RETIRE_FAIL&nbsp;},<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TR_Address(addr,&nbsp;_)&nbsp;=&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;(width,&nbsp;sizeof(xlen))&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(BYTE,&nbsp;_)&nbsp;&nbsp;&nbsp;=&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process_load(rd,&nbsp;vaddr,&nbsp;mem_read(Read(Data),&nbsp;addr,&nbsp;1,&nbsp;aq,&nbsp;rl,&nbsp;false),&nbsp;is_unsigned),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(HALF,&nbsp;_)&nbsp;&nbsp;&nbsp;=&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process_load(rd,&nbsp;vaddr,&nbsp;mem_read(Read(Data),&nbsp;addr,&nbsp;2,&nbsp;aq,&nbsp;rl,&nbsp;false),&nbsp;is_unsigned),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(WORD,&nbsp;_)&nbsp;&nbsp;&nbsp;=&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process_load(rd,&nbsp;vaddr,&nbsp;mem_read(Read(Data),&nbsp;addr,&nbsp;4,&nbsp;aq,&nbsp;rl,&nbsp;false),&nbsp;is_unsigned),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(DOUBLE,&nbsp;64)&nbsp;=&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process_load(rd,&nbsp;vaddr,&nbsp;mem_read(Read(Data),&nbsp;addr,&nbsp;8,&nbsp;aq,&nbsp;rl,&nbsp;false),&nbsp;is_unsigned)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>
}<br>
<br>
/*&nbsp;******************************************************************&nbsp;*/<br>
union&nbsp;clause&nbsp;ast&nbsp;=&nbsp;STORE&nbsp;:&nbsp;(bits(12),&nbsp;regidx,&nbsp;regidx,&nbsp;word_width,&nbsp;bool,&nbsp;bool)<br>
<br>
mapping&nbsp;clause&nbsp;encdec&nbsp;=&nbsp;STORE(imm7&nbsp;@&nbsp;imm5,&nbsp;rs2,&nbsp;rs1,&nbsp;size,&nbsp;false,&nbsp;false)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;word_width_bytes(size)&nbsp;&lt;=&nbsp;sizeof(xlen_bytes)<br>
&nbsp;&nbsp;&lt;-&gt;&nbsp;imm7&nbsp;:&nbsp;bits(7)&nbsp;@&nbsp;rs2&nbsp;@&nbsp;rs1&nbsp;@&nbsp;0b0&nbsp;@&nbsp;size_bits(size)&nbsp;@&nbsp;imm5&nbsp;:&nbsp;bits(5)&nbsp;@&nbsp;0b0100011&nbsp;if&nbsp;word_width_bytes(size)&nbsp;&lt;=&nbsp;sizeof(xlen_bytes)<br>
<br>
/*&nbsp;NOTE:&nbsp;Currently,&nbsp;we&nbsp;only&nbsp;EA&nbsp;if&nbsp;address&nbsp;translation&nbsp;is&nbsp;successful.<br>
&nbsp;&nbsp;&nbsp;This&nbsp;may&nbsp;need&nbsp;revisiting.&nbsp;*/<br>
function&nbsp;clause&nbsp;execute&nbsp;(STORE(imm,&nbsp;rs2,&nbsp;rs1,&nbsp;width,&nbsp;aq,&nbsp;rl))&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;let&nbsp;offset&nbsp;:&nbsp;xlenbits&nbsp;=&nbsp;EXTS(imm);<br>
&nbsp;&nbsp;/*&nbsp;Get&nbsp;the&nbsp;address,&nbsp;X(rs1)&nbsp;+&nbsp;offset.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Some&nbsp;extensions&nbsp;perform&nbsp;additional&nbsp;checks&nbsp;on&nbsp;address&nbsp;validity.&nbsp;*/<br>
&nbsp;&nbsp;match&nbsp;ext_data_get_addr(rs1,&nbsp;offset,&nbsp;Write(Data),&nbsp;width)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;Ext_DataAddr_Error(e)&nbsp;&nbsp;=&gt;&nbsp;{&nbsp;assert&nbsp;(false);&nbsp;RETIRE_FAIL&nbsp;},<br>
&nbsp;&nbsp;&nbsp;&nbsp;Ext_DataAddr_OK(vaddr)&nbsp;=&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;&nbsp;&nbsp;check_misaligned(vaddr,&nbsp;width)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then&nbsp;{&nbsp;handle_mem_exception(vaddr,&nbsp;E_SAMO_Addr_Align());&nbsp;RETIRE_FAIL&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;match&nbsp;translateAddr(vaddr,&nbsp;Write(Data))&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TR_Failure(e,&nbsp;_)&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;{&nbsp;handle_mem_exception(vaddr,&nbsp;e);&nbsp;RETIRE_FAIL&nbsp;},<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TR_Address(addr,&nbsp;_)&nbsp;=&gt;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;eares&nbsp;:&nbsp;MemoryOpResult(unit)&nbsp;=&nbsp;match&nbsp;width&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BYTE&nbsp;&nbsp;&nbsp;=&gt;&nbsp;mem_write_ea(addr,&nbsp;1,&nbsp;aq,&nbsp;rl,&nbsp;false),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HALF&nbsp;&nbsp;&nbsp;=&gt;&nbsp;mem_write_ea(addr,&nbsp;2,&nbsp;aq,&nbsp;rl,&nbsp;false),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WORD&nbsp;&nbsp;&nbsp;=&gt;&nbsp;mem_write_ea(addr,&nbsp;4,&nbsp;aq,&nbsp;rl,&nbsp;false),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DOUBLE&nbsp;=&gt;&nbsp;mem_write_ea(addr,&nbsp;8,&nbsp;aq,&nbsp;rl,&nbsp;false)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;(eares)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MemException(e)&nbsp;=&gt;&nbsp;{&nbsp;handle_mem_exception(addr,&nbsp;e);&nbsp;RETIRE_FAIL&nbsp;},<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MemValue(_)&nbsp;=&gt;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;rs2_val&nbsp;=&nbsp;X(rs2);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;res&nbsp;:&nbsp;MemoryOpResult(bool)&nbsp;=&nbsp;match&nbsp;(width,&nbsp;sizeof(xlen))&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(BYTE,&nbsp;_)&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;mem_write_value(addr,&nbsp;1,&nbsp;rs2_val[7..0],&nbsp;&nbsp;aq,&nbsp;rl,&nbsp;false),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(HALF,&nbsp;_)&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;mem_write_value(addr,&nbsp;2,&nbsp;rs2_val[15..0],&nbsp;aq,&nbsp;rl,&nbsp;false),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(WORD,&nbsp;_)&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;mem_write_value(addr,&nbsp;4,&nbsp;rs2_val[31..0],&nbsp;aq,&nbsp;rl,&nbsp;false),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(DOUBLE,&nbsp;64)&nbsp;=&gt;&nbsp;mem_write_value(addr,&nbsp;8,&nbsp;rs2_val,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aq,&nbsp;rl,&nbsp;false)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;(res)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MemValue(true)&nbsp;&nbsp;=&gt;&nbsp;RETIRE_SUCCESS,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MemValue(false)&nbsp;=&gt;&nbsp;internal_error(&quot;store&nbsp;got&nbsp;false&nbsp;from&nbsp;mem_write_value&quot;),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MemException(e)&nbsp;=&gt;&nbsp;{&nbsp;handle_mem_exception(addr,&nbsp;e);&nbsp;RETIRE_FAIL&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>
}<br>
<br>
/*&nbsp;Put&nbsp;the&nbsp;illegal&nbsp;instructions&nbsp;last&nbsp;to&nbsp;use&nbsp;their&nbsp;wildcard&nbsp;match.&nbsp;*/<br>
<br>
/*&nbsp;******************************************************************&nbsp;*/<br>
<br>
union&nbsp;clause&nbsp;ast&nbsp;=&nbsp;ILLEGAL&nbsp;:&nbsp;word<br>
<br>
mapping&nbsp;clause&nbsp;encdec&nbsp;=&nbsp;ILLEGAL(s)&nbsp;&lt;-&gt;&nbsp;s<br>
<br>
function&nbsp;clause&nbsp;execute&nbsp;(ILLEGAL(s))&nbsp;=&nbsp;{&nbsp;handle_illegal();&nbsp;RETIRE_FAIL&nbsp;}<br>
<br>
/*&nbsp;******************************************************************&nbsp;*/<br>
<br>
/*&nbsp;End&nbsp;definitions&nbsp;*/<br>
end&nbsp;ast<br>
end&nbsp;execute<br>
end&nbsp;encdec<br>
end&nbsp;encdec_compressed<br>
<br>
val&nbsp;decode&nbsp;:&nbsp;bits(32)&nbsp;-&gt;&nbsp;ast&nbsp;effect&nbsp;pure<br>
function&nbsp;decode&nbsp;bv&nbsp;=&nbsp;encdec(bv)<br>
<br>
/*&nbsp;The&nbsp;result&nbsp;of&nbsp;a&nbsp;fetch,&nbsp;which&nbsp;includes&nbsp;any&nbsp;possible&nbsp;error<br>
&nbsp;*&nbsp;from&nbsp;an&nbsp;extension&nbsp;that&nbsp;interposes&nbsp;on&nbsp;the&nbsp;fetch&nbsp;operation.<br>
&nbsp;*/<br>
<br>
union&nbsp;FetchResult&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;F_Ext_Error&nbsp;:&nbsp;ext_fetch_addr_error,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;For&nbsp;extensions&nbsp;*/<br>
&nbsp;&nbsp;F_Base&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;word,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Base&nbsp;ISA&nbsp;*/<br>
&nbsp;&nbsp;F_RVC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;half,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Compressed&nbsp;ISA&nbsp;*/<br>
&nbsp;&nbsp;F_Error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;(ExceptionType,&nbsp;xlenbits)&nbsp;&nbsp;/*&nbsp;standard&nbsp;exception&nbsp;and&nbsp;PC&nbsp;*/<br>
}<br>
/*&nbsp;The&nbsp;default&nbsp;implementation&nbsp;of&nbsp;hooks&nbsp;for&nbsp;the&nbsp;step()&nbsp;and&nbsp;main()&nbsp;functions.&nbsp;*/<br>
<br>
function&nbsp;ext_init()&nbsp;-&gt;&nbsp;unit&nbsp;=&nbsp;()<br>
<br>
function&nbsp;ext_fetch_hook(f&nbsp;:&nbsp;FetchResult)&nbsp;-&gt;&nbsp;FetchResult&nbsp;=&nbsp;f<br>
<br>
function&nbsp;ext_pre_step_hook()&nbsp;&nbsp;-&gt;&nbsp;unit&nbsp;=&nbsp;()<br>
function&nbsp;ext_post_step_hook()&nbsp;-&gt;&nbsp;unit&nbsp;=&nbsp;()<br>
/*&nbsp;Extensions&nbsp;may&nbsp;wish&nbsp;to&nbsp;interpose&nbsp;and&nbsp;transform&nbsp;decoded&nbsp;instructions,<br>
&nbsp;*&nbsp;based&nbsp;on&nbsp;other&nbsp;machine&nbsp;state.&nbsp;&nbsp;This&nbsp;is&nbsp;supported&nbsp;via&nbsp;a&nbsp;post-decode<br>
&nbsp;*&nbsp;instruction&nbsp;hook,&nbsp;the&nbsp;default&nbsp;implementation&nbsp;of&nbsp;which&nbsp;is&nbsp;provided&nbsp;below.<br>
&nbsp;*/<br>
<br>
val&nbsp;ext_post_decode_hook&nbsp;:&nbsp;ast&nbsp;-&gt;&nbsp;ast&nbsp;effect&nbsp;{rreg}<br>
function&nbsp;ext_post_decode_hook(x)&nbsp;=&nbsp;x<br>
<br>
val&nbsp;fetch&nbsp;:&nbsp;unit&nbsp;-&gt;&nbsp;FetchResult&nbsp;effect&nbsp;{escape,&nbsp;rmem,&nbsp;rmemt,&nbsp;rreg,&nbsp;wmv,&nbsp;wmvt,&nbsp;wreg}<br>
function&nbsp;fetch()&nbsp;-&gt;&nbsp;FetchResult&nbsp;=<br>
&nbsp;&nbsp;/*&nbsp;fetch&nbsp;PC&nbsp;check&nbsp;for&nbsp;extensions:&nbsp;extensions&nbsp;return&nbsp;a&nbsp;transformed&nbsp;PC&nbsp;to&nbsp;fetch,<br>
&nbsp;&nbsp;&nbsp;*&nbsp;but&nbsp;any&nbsp;exceptions&nbsp;use&nbsp;the&nbsp;untransformed&nbsp;PC.<br>
&nbsp;&nbsp;&nbsp;*/<br>
&nbsp;&nbsp;match&nbsp;ext_fetch_check_pc(PC,&nbsp;PC)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;Ext_FetchAddr_Error(e)&nbsp;&nbsp;&nbsp;=&gt;&nbsp;F_Ext_Error(e),<br>
&nbsp;&nbsp;&nbsp;&nbsp;Ext_FetchAddr_OK(use_pc)&nbsp;=&gt;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;&nbsp;&nbsp;(use_pc[0]&nbsp;!=&nbsp;bitzero&nbsp;|&nbsp;(use_pc[1]&nbsp;!=&nbsp;bitzero))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then&nbsp;F_Error(E_Fetch_Addr_Align(),&nbsp;PC)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;match&nbsp;translateAddr(use_pc,&nbsp;Execute())&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TR_Failure(e,&nbsp;_)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;F_Error(e,&nbsp;PC),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TR_Address(ppc,&nbsp;_)&nbsp;=&gt;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;mem_read(Execute(),&nbsp;ppc,&nbsp;4,&nbsp;false,&nbsp;false,&nbsp;false)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MemException(e)&nbsp;=&gt;&nbsp;F_Error(e,&nbsp;PC),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MemValue(ibits)&nbsp;&nbsp;&nbsp;=&gt;&nbsp;F_Base(ibits)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
/*&nbsp;The&nbsp;emulator&nbsp;fetch-execute-interrupt&nbsp;dispatch&nbsp;loop.&nbsp;*/<br>
<br>
/*&nbsp;returns&nbsp;whether&nbsp;to&nbsp;increment&nbsp;the&nbsp;step&nbsp;count&nbsp;in&nbsp;the&nbsp;trace&nbsp;*/<br>
function&nbsp;step(step_no&nbsp;:&nbsp;int)&nbsp;-&gt;&nbsp;bool&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;/*&nbsp;for&nbsp;step&nbsp;extensions&nbsp;*/<br>
&nbsp;&nbsp;ext_pre_step_hook();<br>
<br>
&nbsp;&nbsp;let&nbsp;(retired,&nbsp;stepped)&nbsp;:&nbsp;(Retired,&nbsp;bool)&nbsp;=<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;the&nbsp;extension&nbsp;hook&nbsp;interposes&nbsp;on&nbsp;the&nbsp;fetch&nbsp;result&nbsp;*/<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;f&nbsp;:&nbsp;FetchResult&nbsp;=&nbsp;ext_fetch_hook(fetch())&nbsp;in<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match&nbsp;f&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;extension&nbsp;error&nbsp;*/<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F_Ext_Error(e)&nbsp;&nbsp;&nbsp;=&gt;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ext_handle_fetch_check_error(e);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(RETIRE_FAIL,&nbsp;false)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;standard&nbsp;error&nbsp;*/<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F_Error(e,&nbsp;addr)&nbsp;=&gt;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handle_mem_exception(addr,&nbsp;e);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(RETIRE_FAIL,&nbsp;false)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F_Base(w)&nbsp;=&gt;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;ast&nbsp;=&nbsp;decode(w);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nextPC&nbsp;=&nbsp;PC&nbsp;+&nbsp;4;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(execute(ext_post_decode_hook(ast)),&nbsp;true)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br>
<br>
&nbsp;&nbsp;tick_pc();<br>
<br>
&nbsp;&nbsp;/*&nbsp;for&nbsp;step&nbsp;extensions&nbsp;*/<br>
&nbsp;&nbsp;ext_post_step_hook();<br>
<br>
&nbsp;&nbsp;stepped<br>
}<br>
<br>
function&nbsp;loop&nbsp;()&nbsp;:&nbsp;unit&nbsp;-&gt;&nbsp;unit&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;step_no&nbsp;:&nbsp;int&nbsp;=&nbsp;0;<br>
&nbsp;&nbsp;while&nbsp;(true)&nbsp;do&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;stepped&nbsp;=&nbsp;step(step_no);<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;stepped&nbsp;then&nbsp;step_no&nbsp;=&nbsp;step_no&nbsp;+&nbsp;1;<br>
&nbsp;&nbsp;}<br>
}<br>
<br>
<br>
function&nbsp;main&nbsp;()&nbsp;:&nbsp;unit&nbsp;-&gt;&nbsp;unit&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;//&nbsp;PC&nbsp;=&nbsp;__GetSlice_int(64,&nbsp;elf_entry(),&nbsp;0);<br>
&nbsp;&nbsp;PC&nbsp;=&nbsp;sail_zero_extend(0x1000,&nbsp;sizeof(xlen));<br>
&nbsp;&nbsp;print_bits(&quot;PC&nbsp;=&nbsp;&quot;,&nbsp;PC);<br>
<br>
&nbsp;&nbsp;try&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;loop()<br>
&nbsp;&nbsp;}&nbsp;catch&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;Error_not_implemented(s)&nbsp;=&gt;&nbsp;print_string(&quot;Error:&nbsp;Not&nbsp;implemented:&nbsp;&quot;,&nbsp;s),<br>
&nbsp;&nbsp;&nbsp;&nbsp;Error_internal_error()&nbsp;=&gt;&nbsp;print(&quot;Error:&nbsp;internal&nbsp;error&quot;)<br>
&nbsp;&nbsp;}<br>
}<br>
</code>
</body>
</html>